% This is the file where my Master Thesis will be written. It uses the adapted
% LNCS Template.
%
% I'll be using a few codes in the comments, which can be easily looked up:
% * NOTE: theseis-text related comments
% * TODO: thesis-related TODO's
% * WARN: latex/formatting-related warningss
%
% WARN: for running head, subsititute the line below by:
% \documentclass[runningheads,a4paper]{llncs}
\documentclass{llncs}
%
%%% WARN: custom extension
\usepackage{xcolor}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}

%%% GLOSSARIES
\usepackage{glossaries}

%%% inline code
\usepackage{xparse}
\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

%%% figures
\usepackage{graphicx}
\usepackage{wrapfig}

%%% tables
\usepackage{booktabs}


\makeglossaries

\newacronym{tls}{TLS}{Transport Layer Security}%
\newacronym{ssl}{SSL}{Secure Sockets Layer}%
\newacronym{ietf}{IETF}{Internet Engineering Task Force}%
\newacronym{mac}{MAC}{Message Authentication Code}%
\newacronym{psk}{PSK}{Pre-Shared Key}%
\newacronym{rpk}{RPK}{Raw Public Key}%
\newacronym{aead}{AEAD}{Authenticated Encryption With Associated Data}%
\newacronym{pkc}{PKC}{Public Key Cryptography}%
\newacronym{hkdf}{HKDF}{HMAC-based Extract-and-Expand Key Derivation Function}%
\newacronym{html}{HTML}{Hypertext Markup Language}%
\newacronym{https}{HTTPS}{Hypertext Transfer Protocol Secure}%
\newacronym{ecc}{ECC}{Elliptic Curve Cryptography}%
\newacronym{iv}{IV}{Initialization Vector}%
\newacronym{ecdh}{ECDH}{Elliptic Curve Diffie-Hellman}%
\newacronym{ecdhe}{ECDHE}{Elliptic Curve Diffie-Hellman Ephemeral}%
\newacronym{ecdsa}{ECDSA}{Elliptic Curve Digital Signature Algorithm}%
\newacronym{rfc}{RFC}{Request For Comment}%
\newacronym{prf}{PRF}{Pseudo-Random Function}%
\newacronym{rsa}{RSA}{Rivest-Shamir-Adleman}%
\newacronym{dh}{DH}{Diffie-Hellman}%
\newacronym{pms}{PMS}{premaster secret}%
\newacronym{pubk}{PubK}{Public Key}%
\newacronym{privk}{PrivK}{Private Key}%
\newacronym{dsa}{DSA}{Private Key}%
\newacronym{pfs}{PFS}{Perfect Forward Secrecy}%
\newacronym{mitm}{MITM}{Man In The Middle}%
\newacronym{ac}{AC}{Asymmetrical Cryptography}%
\newacronym{sc}{SC}{Symmetrical Cryptography}%
\newacronym{iot}{IoT}{Internet Of Things}%
\newacronym{dtls}{DTLS}{Datagram TLS}%
\newacronym{coap}{CoAP}{Constrained Application Protocol}%
\newacronym{ec}{EC}{Elliptic Curve}%
\newacronym{sca}{SCA}{Side-Channel Attack}%
\newacronym{ocsp}{OCSP}{Online Certificate Status Protocol}
\newacronym{crl}{CRL}{Certificate Revocation List}
\newacronym{ca}{CA}{Certification Authority}
\newacronym{sni}{SNI}{Server Name Indication}
\newacronym{dos}{DoS}{Denial-of-Service}



%%% WARN: added as specified here:
% https://tex.stackexchange.com/questions/272200/table-of-contents-showing-the-title-as-only-entry-latex
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{} % removes author name from TOC
\renewcommand*\l@title[2]{} % removes title name from TOC
\makeatletter
%%%
%
\usepackage{makeidx}  % allows for indexgeneration
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\addtocmark{TLS For IoT} % additional mark in the TOC

\tableofcontents
\newpage

\mainmatter              % start of the contributions
%
\title{Transport Layer Security Protocol For Internet Of Things}
%
\titlerunning{TLS For IoT}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{{Illya Gerasymchuk} \\
\email{illya.gerasymchuk@tecnico.uliboa.pt},\\ WWW home page:
\texttt{https://iluxonchik.github.io/}}
%
\authorrunning{Illya Gerasymchuk} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Illya Gerasymchuk}
%
\institute{Instituto Superior Técnico}
% WARN: supper hacked-in
\supervisors{Ricardo Chaves, Aleksandar Ilic}
\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{TLS, IoT, cryptography, protocol, lightweight cryptography}
\end{abstract}
%
\section{Intoduction}
%
\todo{Intruduce the topic: explain what is IoT; what is TLS; what are the issues with
using RAW TLS with IoT(power, computation, limited resources).}

TCP performance is known to be inefficient in wireless
networks, due to its congestion control algorithm, and the
situation is exacerbated with the low-power radios and lossy
links found in sensor networks. Therefore, the connectionless
UDP is mostly used in the IoT.

\todo{MOTIVATION goes here}
%
\section{Theoretical Background}
\subsection{Symmetric vs Asymmetric Cryptography (Background Section)}

\gls{ac} more expensive than \gls{sc} in terms of performance. This is mainly due
to two facts: larger key sizes are required for \gls{ac} system to achieved the
same level of security as in a \gls{sc} system  and \codeword{CPU}s are slower at performing the underlying
mathematical operations involved in \gls{ac}, namely exponentiation requires
\codeword{O(log e)} multiplications for an exponent \codeword{e}. For example,
the 2016 \codeword{NIST} report \cite{Recommen44:online}
suggests that an \gls{ac} would need to use a secret key with size of \codeword{15360 bits}
to have equivalent security to a \codeword{256-bit} secret key for a \gls{sc} algorithm.
This situation is ameliorated by \gls{ecc}, which requires keys of \codeword{512 bits},
it is still slower than \gls{sc}, though. The 2017 \codeword{BSI} report \cite{Kryptogr1:online} (from the
German federal office for information security) suggests similar numbers.

Another argument for avoiding as much as possible of the \gls{ac} functionality
is that it requires extra storage space to be used and this might be a problem for some \gls{iot} devices,
like \codeword{class 1} devices according to the terminology of constrained-code
networks \cite{RFC7228} which have about \codeword{10KB} of RAM and \codeword{100KB}
of persistent memory. I measured the resulitng size of the complied mbedTLS 2.6.0 library
\cite{SSLLibra13:online} when compiled with and without the \codeword{RSA} module
(located in the \codeword{rsa.c} file), from which I concluded that using that module adds an
extra of \codeword{32KB}.

\subsection{Public Certificates}
\todo{todo}


\subsection{AEAD Ciphers}
\todo{Already have this written, need to shorten}



\subsection{Terminology}

Before describing the related work, I will briefly introduce some terminology that will
be used throughout the document:

\begin{itemize}
  \item \gls{pfs} - property that preserves the confidentiality of past interactions
  even if the long-term secret is compromised.
\end{itemize}

\section{Related Work}

Lightweight cryptography is an important topic in the context of \gls{iot}, since
cryptography a fundamental part of security and it's fundamental for it to be
lightweight in order to run on devices with limited memory and processing
capabilities. A lot of work in \gls{iot} incorporates it in one way or another,
so I'll begin with the work done in this area.

Alex \textit{et al}\cite{Stateoft96:online} explore the topic of lightweight symmetric cryptography,
providing a summary of the lightweight symmetric
primitives from the academic community, the government agencies and even proprietary
algorithms which have been either reverse-engineered or leaked. All of those algorithms
are listed in the paper, alongside relevant metrics. I won't be including the list
here, due to lack of space. The authors also proposed
to split the field into two areas: ultra-lightweight and \gls{iot} cryptography.

The authors systematized the knowledge in the area of lightweight cryptography
in order to define "lightweightness" more precisely. They observed that the design
of lightweight cryptography algorithms vary greatly, the only unifying thread
between them being the low computing power of the devices they're designed to run on.

The most frequently optimized metrics are the memory consumption, the implementation size
and the speed or the throughput of the primitive. The specifics depend on whether
the hardware or the software implementations of the primitives are considered.

If the primitive is implemented in hardware, the memory consumption and the implementation
size are lumped together into its gate area, which is measured in Gate Equivalents (GE),
a metric quantifying how physically large a circuit implementing primitive is.
The throughout is measured in bytes/sec and it corresponds to the amount of plaintext
processed per time unit. If a primitive is implemented in software (typically for
use in micro-controllers), the relevant metrics are the RAM consumption, the code
size and the throughput of the primitive, measured in bytes per CPU cycle.

To accommodate the limitations of constrained devices, most lightweight algorithms
are designed to use smaller internal states with smaller key sizes. After analysis,
the authors concluded that even though at least \codeword{128 bit} block and
key sizes were required from the AES candidates, most of the lightweight
block ciphers use only \codeword{64-bit} blocks, which leads to a smaller memory
footprint in both, software and hardware, while also making the algorithm better suited
for processing smaller messages.

Even though though algorithms can be optimized in implementation: whether it's
a software or a hardware now, dedicated lightweight algorithms are still needed.
This comes down mainly to two factors: there are limitations to the the extent of
the optimizations that you can make and the hardware-accelerated encryption is
frequently vulnerable to various \gls{sca}s (such as the attack done on the
Phillips light bulbs \cite{cryptoeprint:2016:1047}, where the authors were able to
recover a secret key used to authenticate updates, via an \gls{sca}).

It's more difficult to implement a lightweight hash function than a lightweight
block cipher, since standard hash functions need large amounts
of memory to store both: their internal states, for example, \codeword{1600 bits} in case of SHA-3
and the block they're operating on, for example, \codeword{512 bits} in the case of SHA-2.
The required internal state is acceptable for a desktop computer, but not for a
constrained device. Taking this into consideration, the most common approach
taken by the designers is to use a sponge construction with a very small bitate.
A sponge function is an algorithm with an internal state that takes as an input
a bit stream of any length and outputs a bit stream of any desired length. Sponge
functions are used to implement many cryptographic primitives, such as cryptographic
hashes. The bitrate decides how fast the plain text is processed and how fast the
final digest is produced. A small bitrate means that the output will take longer
to be produced, which means that a smaller capacity (the security level)
can be used, which minimizes the memory footpirnt at the cost of slower data
processing. A capacity of \codeword{128 bits} and a bitrate of \codeword{8 bits}
are common values for lighweight hash functions.

Another trend in the lightweight algorithms noticed by the authors is the
preference for ARX-based and bitsliced-S-Box based designs, as well as simple
key schedules.

Finally, a separation of the "lightweight algorithms" defintion into two
distinct fields has been proposed:

\begin{itemize}
  \item \textbf{Ultra-Lightweight Crypto} - algorithms running on very cheap
  devices which are \textbf{not connected to the internet}, which are easily replaceable
  and have a limited life-time. Examples: RFID tags, smart cards and remote car keys.
  \item \textbf{IoT Crypto} - algorithms running on a low-power device,
  \textbf{connected to a global network}, such as the internet. Examples: security cameras,
  smart light bulbs and smart watches.
\end{itemize}

Considering the two definitions above, this work focuses on \textbf{IoT Crypto}
devices. A summary of differences between the both categories is summarized in
table \ref{ul-iot}.

\begin{table}[]
\centering
\caption{A summary of the differences between ultra-lightweight and IoT crypto}
\label{ul-iot}
\begin{tabular}{@{}lll@{}}
\toprule
                           & \textbf{Ultra-Lightweight}          & \textbf{IoT}                           \\ \midrule
\textbf{Block Size}        & 64 bits                             & ≥ 128 bits                             \\
\textbf{Security Level}    & ≥ 80 bits                           & ≥ 128 bits                             \\
\textbf{Relevant Attacks}  & low data/time complexity            & same as "regular" crypto               \\
\textbf{Intended Platform} & dedicated circuit (ASIC, RFID...)   & micro-controllers, low-end CPUs        \\
\textbf{SCA Resilience}    & important                           & important                              \\
\textbf{Functionality}     & one per device, e.g. authentication & encryption, authentication, hashing... \\
\textbf{Connection}        & temporary, only to a given hub      & permanent, to a global network         \\ \bottomrule
\end{tabular}
\end{table}

\todo{WRITE ABOUT LIGHTWEIGHT PUBLIC CRYPTO HERE}

Lightweight cryptography is an important part of my work and there are papers detailing
various algorithms. While an important topic for my solution, I do consider that
I've done sufficient coverage on it, by specifically choosing recent works that
provide an overview of the different areas, rather than focusing on specific
implementations, since the length of this section is limited. The remaining text
in this seciton will be used to describe work done on the (D)TLS protocol in the
context of \gls{iot}.

For the reasons specifed above, the main key exchange mechanism used in IoT
are \gls{psk}s. SK3\cite{S3KScala62:online} proposes a key management architecture for resource-constrained devices,
which allows devices that have no previous, direct security relation to use
TLS or DTLS using one of two approaches: shared symmetric keys or raw public keys.
The resource-constrained device is a server that offers one or more resources,
such as temperature readings. The idea in both approaches is to introduce a third-party
\codeword{trust anchor (TA)} that both, the client and the server use to establish
trust relationships between them.

The first approach is similar to Kerberos\cite{todo}, without requiring any
changes to the original protocol. A client can request a \gls{psk} \codeword{Kc} from the \codeword{TA},
which will generate it and send it back to the client via a secure channel, alongside
a \codeword{psk_identity} which has the same meaning and is used in the same way
as defined in \codeword{RFC PSK}\cite{todo}. When connecting to the server,
the client will then send the \codeword{psk_identity} that it received in the
the (D)TLS handshake and the server will derive the \codeword{Kc}, using the
\codeword{P_hash()} function defined in \cite{RFC5246}.

The second approach consists in the   requesting an APK (the authors never defined
what this acronym stands for, but I assume they mean "Authorization Public Key")
from the TA. In his request,
the client includes his \gls{rpk}, which is used for authorization. The TA
creates an authorizaton certificate, protects it with a MAC and sends it
to the client alongside the server's \gls{pubk}.
The client then sends this APK (instead of the \gls{rpk})
when connecting to the server, which verifies the APK (to authorize the client)
and proceeds with the handshake in the \gls{rpk} mode, as defined in \cite{todo psk rfc}.
To achieve this, a new certificate structure is defined, alongside a new \codeword{certificate_type}.
The new certificate strucure is just the RFC7250 \cite{RFC7250} structure, with an
additonal MAC.

The has function used for key derivation is SHA256. The authors evaluated the
performance of their solution with and without SHA2 hardware acceleration and
concluded that while it had significant impact on key derivation, it had little
impact on the total handshake time (\codeword{711.11 ms} instead of \codeword{775.05 ms}), since most of the time was spent in sending
data over the network and other parts of the handshake, the longest one being
the \codeword{ChangeCiperSpec} message which required the longest processing time
of \codeword{17.79ms}.

6LoWPAN\cite{RFC4944} is a protocol that allows devices with limited processing
ability and power to transmit information wirelessly using the \codeword{IPv6}
protocol. The protocol defines IP Header Compression(IPHC) for the IP header and
Next Header Compression (NHC) for the IP extension headers and the UDP header in \cite{RFC6282}.
The compression relies on the shared context between the communicating peers.

\cite{6LoWPANC53:online} uses this same idea, but with the goal of compressing DTLS headers.
6LoWPAN does not provide ways to compress the UDP payload and layers above, there
is however, a proposed standard\cite{RFC7400} for generic header compression
for 6LoWPANs that can be used to compress the UDP payload. The authors propose
a way to compress DTLS headers and messages using this mechanism.

The paper \cite{6LoWPANC53:online} defines how the \gls{dtls} Record header, the \gls{dtls} Handshake header,
the ClientHello and the ServerHello messages can be compressed, but notes that
the same compression techniques can be used to compress the remaining Handshake
messages. They explore two cases for the header compression: compressing both,
the Record header and the Handshake header and compressing the Record header only,
which is useful after the handshake has completed and the fragment field of the
Record layer contains application data, instead of a handshake message.

\begin{figure}
    \centering
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{img/6lowpan-header.png} % first figure itself
        \caption{\label{fig:6lowpan-header} IPv6 Next Header Compression}
    \end{minipage}\hfill
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{img/6lowpan-ghc-rhs.png} % second figure itself
        \caption{\label{fig:6lowpan-ghc-rhs} LOWPAN\_NHC\_RHS structure}
    \end{minipage}
\end{figure}


All of the cases follow the same basic idea, for this reason I'll only exemplify
one of them. Each \gls{dtls} fragment is carried over in the UDP payload. In this case,
the UDP payload carries a header-like payload (the DTLS record header).
Figure \ref{fig:6lowpan-header} shows the way IPv6 next header compression is done.
The authors use the same value for the \codeword{LOWPAN_NHC Encoding} field (defined in \cite{RFC6282})
as in \codeword{RFC7400} and define the format of the \codeword{In-line Next Header Fields}
(defined in \cite{RFC6282}), which is the compressed DTLS content. The \codeword{LOWPAN_IPHC Encoding}
and \codeword{In-Line IP Fields} fields are used in the IPv6 header compression
and are not in the scope of the paper.

I will exemplify the case where both, the record and the Handshake headers are compressed.
In this case \codeword{LOWPAN_NHC Encoding} will contain the \codeword{LOWPAN_NHC_RHS}
structure (depicted in figure \ref{fig:6lowpan-ghc-rhs}), which is the compressed form of the Record and Handshake headers. The
parts that are not compressed will be contained in the \codeword{Payload} part.
The first four bits represent the ID field and in this case they're fixed to \codeword{1000},
so that the decompressor knows what is being compressed (\textit{i.e} how to interpret
the structure that follows the ID bits). If the \codeword{F} field of the \codeword{LOWPAN_NHC_RHS} structure contains the
bit \codeword{0}, it means that the handshake message is not fragmented, so
the \codeword{fragment_offset} and \codeword{fragment_length} fields are
elided from the Handshake header (common case when a handshake message is not bigger than
the maximum header size), meaning that they're not going to be sent at
all (\textit{i.e.} they're not going to be present in the \codeword{Payload} part).
If the \codeword{F} bit has the value \codeword{1}, the \codeword{fragment_offset}
and \codeword{fragment_length} fields are carried inline (\textit{i.e.} they're
present in the \codeword{Payload} part). The remaining two fields define similar
behavior for other header fields (some of them assume that some default value is present, when a field is elided).
The \codeword{length} field in the Record and Handshake headers are always elided,
since they can be inferred from the lower layers.

The evaluation showed that the compression can save a significant number of bits:
the Record header, that is included in all messages can be compressed by \codeword{64 bits}
(\textit{i.e.} by \codeword{62\%}).

There is also a proposal for TCP header compression for 6LoWPAN\cite{I-D.aayadi-6lowpan-tcphc},
which if adopted, in many cases can compress the mandatory \codeword{20 bytes} TCP header
into \codeword{6 bytes}. This means that the same ideas can be applied to TCP and
TLS as well.

Later, in 2013, Raza \textit{et al.} proposed a security scheme called Lithe\cite{LitheLig40:online},
which is a lightweight security solution for \gls{coap} that uses the same DTLS header
compression technique as in \cite{6LoWPANC53:online} with the goal of implementing
it as a security support for \gls{coap}.\gls{coap}\cite{RFC7959} is a specialized
RESTful Internet Application Protocol for constrained devices. It's designed to easily
translate to HTTP, in order to simplify its integration with the web,
while also meeting requirements such as multicast support and low overhead.
\gls{coap} is like "HTTP for constrained devices".
\gls{coap} can run on most devices that support UDP or a UDP-like protocol.
\gls{coap} mandates the use of \gls{dtls} as the underlying security protocol for
authenticated and confidential communication. There is also a specification \gls{coap}
running on top of TCP, which uses \gls{tls} as its underlying security protocol
currently being proposed \cite{I.D.draft-ietf-core-coap-tcp-tls},
with active work being done in this area.


The authors evaluated their system in a simulated environment in Contiki OS and
they obtained significant gains in terms of packet size (similiar numbers to the
ones obsever in \cite{6LoWPANC53:online}), energy consumption (in average \codeword{15\%} less
energy is used to transmitting and receive compressed packets), processing time
(the compression and decompression time of DTLS headers is almost negligible)
and network-wide response times(up to \codeword{50\%} smaller RTT). The
gains in the mentioned measures are the largest when the compression avoids
fragmentation (in the paper, for payload size of \codeword{48 bytes}).

Angelo \textit{et al} \cite{Security5:online} proposed to integrate the \gls{dtls} protocol
inside the \gls{coap}, while also exploiting \gls{ecc} optimizations and minimizing
ROM occupancy. They've implemented their solution on an off-the-shelf mote platform
and evaluated its performance. \gls{dtls} was designed to protect web application communication, as a result,
it has a big overhead in \gls{iot} scenarios. Besides that, it runs over UDP,
so additional mechanisms are needed to provide the reliability and ordering
guarantee. With this in mind, the authors wanted to design a version of \gls{dtls}
that's both: minimizes the code size and the number of exchanged messages, resulting
in an optimized Handshake protocol.

In order to minimize the code size occupied by the \gls{dtls} implementation, they
decided to delegate the tasks of \textbf{reliability} and \textbf{fragmentation} to
\gls{coap}. This means that the code responsible for those functionalities,
can be removed altogether from the \gls{dtls} implementation, thus reducing ROM
occupancy. This part of their work was based on an informational RFC draft\cite{I-D.draft-keoh-dtls-profile-iot}, in which the
authors profiled \gls{dtls} for \gls{coap}-based \gls{iot} applications and proposed
the use of a RESTful \gls{dtls} Handshake which relies on \gls{coap} block-wise
transfer to address the fragmentation issue.

To achieve this they  proposed the use of a RESTful \gls{dtls} connection as a \gls{coap} resource,
which is created when a new secure session is requested.
The authors exploit the the \gls{coap}s capability to provide connection-oriented
communication offered by its message layer. In particular, each \codeword{Confirmable}
\gls{coap} message requires an \codeword{Acknowledgement} message\cite{RFC7252T66:online},
which acknowledges that a specific \codeword{Confirmable} message has arrived, thus
providing reliable retransmission.

Instead of leaving the fragmentation function to \gls{dtls}, it was
delegated to the block-wise transfer feature of \gls{coap}\cite{RFC7959}, which was developed
to support transmission of large payloads. This approach has two advantages: first, the code in the \gls{dtls}
layer responsible for this function can be removed, thus reducing ROM occupancy
and second, the fragmentation/reassembly process burdens the lower Layers
with state that is better managed in the application layer.

The authors also optimized the implementation of basic operations on which
many security protocols, such as \gls{ecdh} and \gls{ecdsa} rely upon. The first
optimization had to do with modular arithmetic on large integers. A set of optimized
assembly routines based on \cite{Comparin25:Online} allow the improved use of
registers, reducing the number of memory operations needed to perform
operations such as multiplications and square roots on devices with \codeword{8-bit}
registers.

Scalar multiplication is often the most expensive operation in \gls{ec} based
cryptography, therefore optimizing it is of high interest. The authors used a
technique called \textit{IBPV} described in \cite{LowcostS87:online}, which is based on precumputation
of a set of Discrete Log pairs. I will refrain from going into the mathematical details,
since they're not relevant for this description. The \textit{IBPV} technique was used
to improve the performance of the \gls{ecdsa} signature and was also extended to the
\gls{ecdh} protocol. In order to reduce the time it takes to do the \gls{ecdsa}
signature verification, the \textit{Shamir trick} was used, which allows
to perform the sum of two scalar multiplications (frequent operation in \gls{ec} cryptography)
faster than performing two independent scalar multiplications.

The results showed that the \gls{ecc} optimizations
outperform the scalar multiplication in the state of the art class 1 device platforms,
while also improving the the network lifetime by a factor of up to $6.5$ with
respect to a standard, non-optimized implementation. Leaving reliability and
fragmentation tasks to \gls{coap}, reduces the \gls{dtls} implementation code size
by approximately $23\%$.

\codeword{RFC 7925}\cite{rfc7925} describes a \gls{tls} and \gls{dtls} 1.2
profile for \gls{iot} devices that offers communication security services
for \gls{iot} applications and is reasonably implementable on many constrained devices.
In this context, "profile" means available configuration options (ex: which
cipher suites to use) and protocol extensions that are best suited for \gls{iot} devices.
The document is rather lengthy, so I'll summarize the most important parts. I will
also provide a brief description of some RFCs that I consider to be relevant for
my work.

The RFC explores both cases constrained clients and constrained servers, specifying
a profile for each one and describing the main challenges faced in each scenario.
The profile specifications for constrained clients and servers are very similar.
Code reuse in order to minimize the implementation size is recommended. For example, an \gls{iot} device
using a network access solution based on \gls{tls}, such as EAP-TLS\cite{rfc5216}
can reuse most parts of the code for (D)TLS at the application layer.

For the credential types the profile considers 3 cases:

\begin{itemize}
  \item \gls{psk} - authentication based on \gls{psk}s is described in
  \codeword{RFC 4249}\cite{rfc4279}. When using \gls{psk}s, the client indicates which
  key it uses by including a \gls{psk} identity in its ClientKeyExchange message.
  A server can have different \gls{psk} identities shared with different clients.
  An identity can have any size, up to a maximum of \codeword{128 bytes}.
  The profile recommends the use of shorter \gls{psk} identities and specifies
  \codeword{TLS_PSK_WITH_AES_128_CCM_8} as the only mandatory-to-implement
  ciphersuite to be used with \gls{psk}s, just like \gls{coap} does. If a \gls{pfs}
  ciphersuite is used, ephemeral \gls{dh} keys should not be reused over multiple protocol exchanges.

  \item \gls{rpk} - the use of \gls{rpk}s in (D)TLS is described in \codeword{RFC 7250}\cite{rfc7250}.
  With \gls{rpk}s, only a subset of the information is found in typical certificates
  is used: namely the \codeword{SubjectPublicKeyInfo} structure, which contains
  the necessary parameters to describe the public key (the algorithm identifier
  and the public key itself). Other PKIX certificate\cite{RFC5280} parameters are
  omitted, making the resulted \gls{rpk} smaller in size, when compared to the
  original certificate and the code to process the keys simpler. In order for the
  peers to negotiate the \gls{rpk} use, two new extensions have been defined:
  one for the client to list the certificate types that it supports (sorted by order of preference) and one for
  the indicate which one it chose. To further reduce the size of the implementation, the \codeword{RFC 7250}
  recommends the use of the \gls{tls} Cached Information extension\cite{RFC7924}, which
  enables the \gls{tls} peers to exchange just the fingerprint (a shorter sequence of bytes
  used to identify a \gls{pubk}) of the \gls{pubk}. The only mandatory-to-implement
  ciphersuite to be used with \gls{rpk}s is \codeword{TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8},
  just like with \gls{coap}. Note that the ciphersuite makes the use of \gls{aead}.

  \item certificate - conventional certificates can also be used. The support
  for the Cached Information extension\cite{RFC7924} and the \codeword{TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8}
  ciphersuite is required. The profile restricts the use of named curves to
  the ones defined in \cite{RFC4492}. For certificate revocation, neither the
  \gls{ocsp}\cite{RFC6960}, nor the \gls{crl}\cite{RFC5280} mechanisms are used, instead this task is delegated to
  the software update functionality. The Cached Information extension does not
  provide any help with caching client certificates. For this reason, in cases
  where client-side certificates are used and the server is not constrained,
  the support for client certificate URLs is required. The client certificates URL
  extension\cite{RFC4366} allows the clients to point the server to a URL from
  which it can obtain its certificate, which allows constrained clients to
  save memory and amount of transmitted data. The Trusted CA Indication\cite{RFC6066}
  extension allows the clients to indicate which trust anchors they support, which is useful
  for constrained clients that due to memory limitation posses only a small number
  of \gls{ca} root keys, since it can avoid repeated handshake failures. If the clients interacts with
  dynamically discovered set of (D)TLS servers, the use of this extension is recommended,
  if that set is fixed, it is not recommended.

\end{itemize}

The signature algorithms extension\cite{RFC5246} allows the client to indicate
to the server which signature/hash pairs it supports to be used in digital signatures.
The client must send this extension to indicate the use of \codeword{SHA-256},
otherwise the defaults defined in \cite{RFC5246} are used. This extension is not
applicable when the \gls{psk}-based ciphersuites are used.

The profile mandates that constrained clients must implement the session
resumption to improve the performance of the handshake since this will lead to
less exchanged messages, lower computational overhead, since only symmetric cyrptography
is used, and it requires less bandwidth. In case the server is constrained, but
the client is not, the client must implement the Session Resumption Without
Server-Side State mechanism\cite{RFC5077}, which is achieved through the
use of tickets. The server encapsulates the state into a ticket and forwards it to
the client, which can subsequently resume the session by sending back that ticket.
If both, the client and the server are constrained, both of them should implement
\codeword{RFC 5077}\cite{RFC5077}.

The use of compression is not recommended for two reasons. First, \codeword{RFC7525}\cite{RFC7525}
recommends disabling (D)TLS level compression, due to attacks such as \codeword{CRIME}\cite{TODO}.
\codeword{RFC7525} provides recommendations for improving the security of deployed services
that use \gls{tls} and \gls{dtls} and was published as a response to the various
attacks on (D)TLS that have emerged over the years. Second, for \gls{iot} applications,
the (D)\gls{tls} compression is not needed, since application-layer protocols are hightly
optimized and compression at the (D)TLS layer increases the implementation's size and complexity.

\codeword{RFC6520} defines a heartbeat mechanism to test whether the other peer
is still alive. The implementation of this extension is recommended for server
initiated messages. Note that since the messages to the client will most likely
get blocked by the middleboxes, the initial connection set up is initiated by the
client and then kept alive by the server.

Many of the usual sources of entropy, such as the timing of keystrokes and the
mouse movements will not be available on many \gls{iot} devices, which means that
either alternative ones need to be found or dedicated hardware must be added.
\gls{iot} devices using (D)\gls{tls} must find ways to offer to generate quality
random numbers, the guidelines and requirements for which can be found in \codeword{RFC4086}\cite{rfc4086},
since they play an essential role in the overall security of the protocol.

Implementations compliant with this profile must use \gls{aead} ciphers, this means
that encryption and \gls{mac} computation are no longer independent steps, which means
that neither encrypt-then-MAC\cite{RFC7366}, nor the truncated MAC\cite{RFC6066} extensions are applicable
to this specification and must not be used.

The \gls{sni} extension\cite{RFC6066} defines a mechanism for a client to
tell a (D)TLS server the name of the server it wants to connect to. This is
crucial in case when multiple websites are hosted under the same IP address.
The implementation of this extension is required, unless the (D)\gls{tls}
client does not interact with a server in a hosting environment.

The maximum fragment length extension\cite{RFC6066} lowers the maximum fragment
length support of the record layer from $2^14$ to $2^9$. This extension allows
the client to indicate the server how much of the incoming data it's able to buffer,
allowing the client implementations to lower their RAM requirements, since it doesn't
not need to accept packets of large size, such as the 16K packets required by
plain (D)\gls{tls}. For that reason, client implementations must support this
extension.

The Session Hash Extended Master Secret Extension \cite{RFC7627} defines an extension
that binds the master secret to the log of the full handshake, thus preventing
\gls{mitm} attacks, such as the tripple handshake\cite{TripleHa89:online}. Even though the
ciphersuites recommended by the profile are not vulnerable to this attack, the
implementation of this extension is advised. In order to prevent the renegotiation
attack\cite{RFC5746}, the profile requires the \gls{tls} renegotiation feature
to be disabled.

With regards to the key size recommendations, the authors recommend symmetric keys
of at least \codeword{112 bit}, which corresponds to a \codeword{233-bit} \gls{ecc}
key and to a \codeword{2048} \gls{dh} key. Those recommendations are made
conservatively under the assumption that \gls{iot} devices have a long expected
lifetime ($10+$ years) and that those key recommendations refer to the long-term
keys used for device authentication. Keys that are provisioned dynamically
and used for protection of transactional data, such as the ones used in
(D)\gls{tls} ciphersuites, may be shorter, dependent on the sensitivity of
transmitted data.

Even though \gls{tls} defines a single stream cipher: the RC4, its use is no longer
recommended due to cryptographic weaknesses described in \codeword{RFC 7465}\cite{RFC 7465}.

The \codeword{RFC7925}\cite{rfc7925} points out the importance of designing a software
update mechanism into an \gls{iot} system is crucial to ensure that potential vulnerabilities
can be fixed and that the functionality can be enhanced. The software update mechanism
is important to change configuration information, such as trust anchors and
other secret-key related information. Although the profile refers to \codeword{LM2M}\cite{OpenMobi29:online}
as an example of protocol that comes with a suitable software update mechanism,
there has been new work done in this area since the release of this profile.
Namely, there is a document specifying an architecture for a frimware update
mechanism for \gls{iot} devices\cite{I-D.draft-moran-suit-architecture} currently in "Internet-Draft" state.

\subsection{How My Work Differs From What Already Has Been Done}

Most of the work described above either proposes a solution that's tied to a
specific protocol, such as \gls{coap}, or requires an introduction of a third-party
entity, such as the trust anchor in the case of SK3\cite{S3KScala62:online} or
even both. This two main issues: first, if the developer wants to use (D)\gls{tls}
without using the specific protocol for which the solution was tuned for (such as \gls{coap}),
he might see himself in some trouble, and second the requirement of a third-party
introduces additional cost and complexity, which will be a big <resistance factor>
in adopting that technology. This is specially true for developers who are doing
hobby projects or projects for small businesses, leaving the communications insecure
in the worse case scenario. My goal is to design a solution that can be used out
of the box and is not tailored towards any specific protocol, that's fully backwards
compatible with the original protocol and that can be used with either \gls{tls}
or \gls{dtls}. The solution would be a (D)\gls{tls} version whose details can differ,
depending on the requirements of the context it's being used in, in that sense,
it would be similar to a framework.

Most of the work that has been done has been centered around \gls{dtls},
even though most of the solutions can be applied to both.
I want explore \gls{tls} optimization more. There is clearly a need for that, specially with \gls{coap} over
TCP and \gls{tls} standard being currently developed. The \gls{coap} protocol is the HTTP
for constrained devices and the mentioned standard does not explore any \gls{tls}
optimizations, and since any \gls{iot} device using it in the future would benefit
them, this is an important area to explore. None of the related work centered around
(D)TLS 1.3, mainly this is because the protocol is still in draft stages, I wouldn't expect
however, major changes to its design at this point.

In the process of my work on this master thesis, I've made several
contributions to the \gls{tls} 1.3 specification and have been officially
recognized as a contributor, my name will be on the final document specifying
the \gls{tls} 1.3 standard. \gls{tls} 1.3 is significantly different from \gls{tls} 1.2
and there has been no work like \codeword{RFC 7925}\cite{rfc7925} done for (D)TLS 1.3
and it would be interesting to explore this. \gls{tls} 1.3 has many fundamental changes
to the way the handshake is done, bringing many new features, whose ideas can
be incorporated into my proposed solution and even backported to \gls{tls} 1.2

%\end{enumerate}

\section{Background}
%
\todo{Tell that first I describe the parts of TLS that are common to both and then
specialize for TLS 1.2 and TLS 1.3}
%
\section{The TLS Protocol}
TLS stands for Transport Layer Security, it's a \textbf{client-server} protocol
that runs on top a \textbf{connection-oriented and reliable transport protocol},
such as \textbf{TCP}. Its main goal is to provide \textbf{privacy} and \textbf{integrity}
between the two communicating peers. Privacy implies that a third party will not
be able to read the data, while integrity means that a third party will not be
able to alter the data.

In the TCP/IP Protocol Stack, \gls{tls} is placed between the \textbf{Transport}
and \textbf{Application} layers. It's designed to make the application developer's
life easier: all the developer has to do is create a "secure" connection, instead
of a "normal" one.

\todo{Re-write what's below. It's good to include something like this,
but I need to work on the wording.}
From the top-level view, in a typical connection, there are three basic steps
that \gls{tls} is responsible for:
\begin{enumerate}
  \item \textbf{Negotiate security parameters} - the communicating peers agree on
  a set of security parameters to be used in a \gls{tls} connection, such as the
  algorithm used for bulk data encrytion, as well as the secret keys.
  \item \textbf{Authenticate one to another} - usually only the server authenticates
  to the client.
  \item \textbf{Communicate securely} - use the negotiated security parameters
  to encrypt and authenticate the data, communicating securely one with another.
\end{enumerate}


%%% NOTE: place this in intro? Is this even needed?
%%% NOTE: review, rephrase
%%% NOTE: find better placement
\subsubsection{SSL vs TLS: What's The Difference?}
You will find the names \gls{ssl} and \gls{tls} used interchangeably in the literature,
so I think it's important to distinguish both. \gls{tls} is an evolution of the \gls{ssl} protocol. The protocol changed
its name from \gls{ssl} to \gls{tls} when it was
standardized by the \gls{ietf}.\gls{ssl}
was a proprietary protocol owned by Netscape Communications, and The \gls{ietf}
decided that it was a good idea to standarize it, which resulted in \codeword{RFC 2246} \cite{RFC2246},
specifying \gls{tls} 1.0, which was nothing more than a new version \gls{ssl} 3.0,
very few changes were made.
%
% TODO: add some data supporting the TLS 1.2 usage claim
In this document, I'll be concentrating on \gls{tls} 1.2 and \gls{tls} 1.3 protocols.
The first one is the most recently standardized version of \gls{tls} and the latter
is currently and in-draft version with many improvements and optimizations relevant
for the topic of this dissertation. Despite the protocol name not suggesting it \gls{tls} 1.3 is
very different from \gls{tls} 1.2, in fact, it should've probably been called
\gls{tls} 2.0 instead. For this reason, I will first describe what is common to
both protocols and then go into the relevant details about each one.
%

\todo{Explain what RFCs are?}
%
\subsection{Security Services}
%
\gls{tls} provides the following 3 security services:
\begin{itemize}
\item \textbf{authentication} - both, \textbf{peer entity} and \textbf{data origin} (or \textbf{integrity})
authentication.
\subitem \textbf{peer entity authentication} - we can be sure that we’re talking to certain entity, for example, \codeword{www.google.com}.
This is achieved thought the use of \textbf{asymmetrical} or \gls{pkc} (for example, \codeword{RSA} and \codeword{DSA})
or \textbf{symmetric key cryptography}, using a \gls{psk}.
\item \textbf{confidentiality} - the data transmitted between the communicating
entities (the client and the server) is encrypted. Symmetric cryptography is
used of data encryption (for exmaple, \codeword{AES}).
\item \textbf{integrity} (also called \textbf{data origin authentication}) - we can be sure that the data was not modified or forged,
\textit{i.e.}, be sure that the data that we’re receiving is coming from the expected entity (for example, we can be sure
that the \codeword{index.html} file sent to us when we connected to \codeword{www.google.com} in fact
came from \codeword{www.google.com} and that it was not modified (i.e tampered with) en
route by an attacker (\textbf{data integrity}). This is achieved through the use
of a keyed \gls{mac} or an \gls{aead} cipher.
\end{itemize}

Despite using \gls{pkc}, \gls{tls} does \textbf{not} provide \textbf{non-repudiation services}:
neither \textbf{non-repudiation with proof of origin}, which addresses the user denying
having sent a message, not \textbf{non-repudiation with proof of delivery}, which
addresses the user denying the receipt of a message. This is due to the fact, that
instead of using \textbf{digital signatures}, either a keyed \gls{mac} or an \gls{aead}
cipher is used, both of which require a \textbf{shared secret} to be used.

You are not required to use all of the 3 security services in every situation.
You can think of \gls{tls} as a framework that allows you to select which security
services you want to use for a communication session. As an example, you might
ignore certificate validation, which means you're ignoring the \textbf{authentication}
guarantee. There are some differences regarding this claim between \gls{tls} 1.2
and \gls{tls} 1.3, for example, while in the first you have a \codeword{null}
cipher (no authentication, no confidentiality, no integrity), in the latter
this is not true, since it deprecated all non-\gls{aead} ciphers in favor of
\gls{aead} ones.

\subsubsection{Cipher Spec vs Cipher Suite}

The meaning of these terms differs in \gls{tls} 1.2 and \gls{tls} 1.3. For \gls{tls} 1.2,
\textbf{cipher spec} defines the message encryption algorithm and the message
authentication algorithm, while the \textbf{cipher suite} is the \textbf{cipher spec},
alongside the definition of the \textbf{key exchange} algorithm and the \gls{prf} (used in key generation). In \gls{tls} 1.3, the
 \textbf{cipher spec} has been removed altogether, since the  \textbf{ChangeCipherSpec}
 protocol has been removed. The concept of \textbf{cipher suite} has been updated
 to define the pair of \gls{aead} algorithm and hash function to be used with
 \gls{hkdf}: in \gls{tls} 1.3 the  \textbf{key exchange} algorithm is negotiated via
 extensions. You'll find more details on this below.

\subsection{TLS (Sub)Protocols}

In reality \gls{tls} is composed of several protocols(illustrated in \ref{fig:tls-subprotocols}), a brief description of each
one of which follows:
\begin{itemize}
  \item \textbf{\gls{tls} Record Protocol} - the lowest layer in \gls{tls}. It's
  the layer that runs directly on top of \textbf{TCP/IP} and it serves as an
   \textbf{encapsulation for the remaining sub-protocols} (\codeword{4} in case of \gls{tls} 1.2
   and \codeword{3} in case of \gls{tls} 1.3). To the  \textbf{Record Protocol},
   the remaining sub-protocols are what \codeword{TCP/IP} is to \codeword{HTTP}.
   A \gls{tls} Record is comprised of 4 fields, with the first 3 comprising the
   \gls{tls} Record header: a 1-byte record \codeword{type},
   specifying the type of record that's encapsulated (ex: value \codeword{0x16}
   for the handshake protocol), a 2-byte \codeword{TLS version} field, a
   2-byte \codeword{length} field (which means that a maximum \gls{tls} Record size
   is of \codeword{16384} bytes), specifying the length of the data in the record, excluding
   the header itself and a \codeword{fragment} field whose size in bytes is specified
   by the \codeword{length} field, which contains data that's
   transparent to the Record layer and should be dealt by a higher-level protocol,
   specified by the \codeword{type} field. This is illustrated in figure \ref{figure:tls-record-header}.
  \item \textbf{\gls{tls} Handshake Protocol} - the core protocol of \gls{tls}.
  Allows the communicating peers to \textbf{authenticate} one to another and negotiate
  a \textbf{cipher suite} (\textbf{cipher suite} and key exchange algorithm in case of \gls{tls} 1.3) which will be used to provide the security services. For \gls{tls} 1.2,
  \textbf{compression} method is also negotiated here.
  \item \textbf{\gls{tls} Alert Protocol} - allows the communicating peers to
  signal potential problems.
  \item \textbf{\gls{tls} Application Data Protocol} - used to transmit data securely.
  \item \textbf{\gls{tls} Change Cipher Spec Protocol} (removed in \gls{tls} 1.3) -
  used to activate the initial \textbf{cipher spec} or change it during the connection.
\end{itemize}

% src: https://tex.stackexchange.com/questions/5769/two-figures-side-by-side
\begin{figure}
    \centering
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{img/record-header.jpg} % first figure itself
        \caption{\label{fig:tls-record-header} TLS Record header}
    \end{minipage}\hfill
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[width=1.0\textwidth]{img/tls-sub-protocols.png} % second figure itself
        \caption{\label{fig:tls-subprotocols} TLS (Sub)protocols and Layers}
    \end{minipage}
\end{figure}

\paragraph{TLS Connections and Sessions}

\todo{define what it means to be cryptographically protected?}

It's important to distinguish between a \textbf{TLS session} and a \textbf{TLS connection}.
\begin{itemize}
  \item \textbf{TLS sesion} - assosciation between two communicationg peers that's
  created by the \textbf{TLS Handshake Protocol}, wich defines a set of negotiated paramters
  (cyrptographic and others, depending on the \gls{tls} version, such as
  the compression algorithm) that are used by the \textbf{TLS connections associated
  with that session}. A single \textbf{TLS session} can be shared among multiple
  \textbf{TLS connections} and its main purpuse is to avoid the expensive negotiation
  of new parameters for each \textbf{TLS connection}. For example, let's say
  you download an \gls{html} page over \gls{https} and that page referrences
  some images from that same server, also using \gls{https}, instead of your
  web browser negotiating a new \gls{tls} session again, it can re-use the the
  one you established to download the \gls{html} page in the first place,
  saving time and computational resources. Session resumption can be done using various
  approaches, such as \textbf{session identifiers}, described throughout \codeword{Section 7.4}
  of \codeword{RFC 5246} \cite{RFC5246}, \textbf{session tickets}, defined in
  \codeword{RFC 5077} \cite{RFC5077}. \todo{Re-write example better.}
  \item \textbf{TLS connection} - used to actually transmit the cryptographically
  protected data. For the data to be cryptographically protected, some parameters,
  such as the \codeword{secret keys} used to encrypt and authenticate the transmitted
  data need to be established; this is done when a \textbf{TLS session} is created,
  during the \textbf{TLS Handshake Protocol}.
\end{itemize}

\subsubsection{\gls{tls} Record Processing}
A \gls{tls} record must go through some processing before it can tbe sent over the netwrok.
This processing involves the following steps (\codeword{4} for \gls{tls} 1.2 and \codeword{3} for \gls{tls} 1.3):

\begin{enumerate}
  \item \textbf{Fragmentation} - the \gls{tls} \codeword{Record Layer} takes arbitrary-length data and \textbf{fragments}
  it into manageable pieces: each one of the resulting fragments is called a \codeword{TLS Plaintext}.
  Client message boundaries are not preserved, which means that multiple messages
  of the same type may be placed into the same fragment or a single message may
  be fragmented across several records.
  \item  \textbf{Compression} (removed in \gls{tls} 1.3) - the \codeword{TLS Record Layer} compresses the
  \codeword{TLSPlaintext} structure according to the negotiated compression method,
  outputting \codeword{TLSCompressed}. Compression is optional. If the negotiated compression
  method is \codeword{null}, \codeword{TLSCompressed} is the same as \codeword{TLSPlaintext}.
  \item \textbf{Cryptographic Protection} - in case of \gls{tls} 1.2, either an
  \gls{aead} cipher or a separate encryption and \gls{mac} functions transform a
  \codeword{TLSCompressed} fragment into a \codeword{TLSCipherText} fragment. In case
  of \gls{tls} 1.3, the \codeword{TLSPlaintext} fragment is transformed into a \codeword{TLSCipherText}
  by applying an \gls{aead} cipher.
  \item Append the \textbf{TLS Record Header} - encapsulate \codeword{TLSCipherText}
  in a \codeword{TLS Record}.
\end{enumerate}

\begin{wrapfigure}{r}{0.4\textwidth}
\centering
\includegraphics[width=0.7\textwidth]{img/tls-record-processing.jpg}
\caption{\label{fig:tls-record-processing}TLS Record Processing}
\end{wrapfigure}

The process described above, as well as the structure names are depicted in figure \ref{fig:tls-record-processing}.
Step \codeword{2} is not present in \gls{tls} 1.3. The structure names are exactly as the appear in the \gls{tls} specifications.

\subsection{TLS Keying Material}
Secret keys are at the base of most cryptographic operations.
In order for both communicating peers to be able to encrypt and decrypt data
using symmetric cyrpto aglorithms, they need to \textbf{share} the same key
somehow. In \gls{tls}, both, the client and a server derive the \textbf{same set of keys}
independetely, through the exchanged messages in the \gls{tls} Handshake Protocol.

When communicating with one another, the client uses one key to
encrypt the data to be sent to the server and another different key to decrypt the data
that it receives from the server. This means that in order to deal with data
encryption and decryption, both of the communicating entities have two keys:
one to encrypt the outgoing data and one to decrypt the incoming data. Those keys
have different names in \gls{tls} 1.2 and \gls{tls} 1.3, but they serve the same
basic purpose. In this general description, I'll refer to them as \codeword{client_write key}
(used by the client to encrypt the data to be sent), \codeword{client_read_key}(used by the client to
decrypt the incoming data from the server), \codeword{server_write_key}(used by the server to encrypt
the data to be sent) and \codeword{server_read_key}(used by the server to decrypt the incoming
data from the client). Note, that the following relationships must hold:
\codeword{client_write_key == server_write_key} and \codeword{client_read_key == server_write_key}.

Besides the secret keys mentioned previously, in \gls{tls} 1.2 you might also have other ones,
depending on the cipher suite in use. \todo{Describe this in a little more detail,
giving examples, when describing TLS 1.2 Key Managment}.

\gls{tls} 1.3's keying material generation is a little more complex, since different
keys are used to encrypt data throughout the Handshake Protocol, as well a new key
is generated for the Application Data protocol. This can be explained by the fact
that while in \gls{tls} 1.2 the data only begins to be encrypted after the handshake
is complete, in the Application Data protocol, the encryption begins earlier,
\gls{tls} 1.3, with some of the Hanshake messages encrypted, as well as features
such as \textbf{early client/server data} and \textbf{0-RTT Data}.

With this the common description of the \gls{tls} of protocols ends and we'll jump
into the specifics of the two verions. I'll be mostly concentrating on the
 \textbf{Handshake Protocol}, since this is where my work will be concentrated and
 it's the main part, where the most interesting and important things happen.

\subsection{TLS 1.2}
The latest standardized version of \gls{tls} is 1.2 and it's defined in \codeword{RFC 5246} \cite{RFC5246}.
\todo{DESCRIBE TLS 1.2 in genreal, put images of handshakes here, later refer to them
in the specific parts, just like the tls RFCs do}.

\section{TLS 1.2 Keying Material Generation}
The generation of secret keys, used for various cryptographic operations involves the
following steps (in order):

\begin{itemize}
  \item Generate the \textbf{premaster secret}
  \item From the \textbf{premaster secret} generate the \textbf{master secret}
  \item From the \textbf{master secret} generate the various secret keys, which
  will be used in the cryptographic operations.
\end{itemize}

\todo{talk about all of the keys present in TLS 1.2 HERE}

\section{TLS 1.2 Key Exchange Methods}
The way the \textbf{permaster secret} is generated depends on the key exchange
method used. In fact, this is the only phase of the keying material generation
phase that is variable for a fixed cipher suite (because a cipher suite defines
the \gls{prf} function to be used), the rest remains exactly the same. The derivation
of the \textbf{master secret} from the \textbf{premaster secret}, as well as the
derivation of the bulk encryption keys, \gls{mac} keys and \gls{iv}s from the \textbf{master secret}
that follows \textbf{is not impacted by the key exchange method} in use.

You have quite a few choices when it comes to key exchange methods. Some of them
are defined in the base spec (\codeword{RFC5246} \cite{RFC5246}), while others
in separate \codeword{RFCs} (such as the \gls{ecc} based key exchange, specified
in \codeword{RFC4492} \cite{RFC4492}).

The base spec specifies 4 key exchange methods, one using \gls{rsa} and 3 using
\gls{dh}:

\begin{itemize}
  \item static \gls{rsa} (\codeword{RSA}) [removed in \gls{tls} 1.3] - the client generates the \gls{pms}, encrypts it with the
  server's \gls{pubk} (which it obtained from the server's \codeword{X.509}certificate),
  sending it to the server, which decrypts it using the corresponding \gls{privk}.
  This key exchange method offers authenticity, but does not offer \gls{pfs}.
  \item anonymous \gls{dh} (\codeword{DH_annon}) [removed in \gls{tls} 1.3] - a \gls{dh} key exchange is
  performed and an \textbf{ephemeral} key is generated, but the exchanged \gls{dh}
  parameters are \textbf{not authenticated}, making the resulting key exchange
  vulnerable to \gls{mitm} attacks. \gls{tls} 1.2 spec states that cipher suites
  using \codeword{DH_annon} \textbf{must not} be used, unless the application
  layer explicitly requests so. This key exchange offers \gls{pfs}, but no
  authenticity.
  \item fixed/static \gls{dh} (\codeword{DH}) [removed in \gls{tls} 1.3] - the server's/client's public \gls{dh} parameter
  is embedded in its certificate. This key exchange method offers authenticity,
  but does not offer \gls{pfs}.
  \item epehemeral \gls{dh} (\codeword{DHE}) - each run of the protocol, uses
  different pubic \gls{dh} parameters, which are generated dynamically. This results
  in a different, epehemeral key being generated every time. The public parameters
  are then digitally signed in some way, usually using the sender's private
  \gls{rsa} (\codeword(DHE_RSA)) or \gls{dsa} (\codeword{DHE_DSS}) key. This key
  exchange offers both authenticity and \gls{pfs}.
\end{itemize}

When either of the \gls{dh} variants is used, the value resulting from the exchange is used
as the \gls{pms} (without the leading \codeword{0}'s). Usually, only the server's
authenticity is desired, but client's can also be achieved if it provides the
server its certificate. Whenever the server is authenticated, the server is secure
against \gls{mitm} attacks. Table \ref{kemps} summarizes the security properties
offered by each key exchange method.

\begin{table}[]
\centering
\caption{Key exchange methods and security properties}
\label{kemsp}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Key Exch Meth} & \multicolumn{1}{l|}{Authentication} & PFS                    \\ \hline
RSA                          & X                                   &                        \\ \hline
DH\_anon                     & \multicolumn{1}{l|}{}               & \multicolumn{1}{c|}{X} \\ \hline
DH                           & X                                   &                        \\ \hline
DHE                          & X                                   & \multicolumn{1}{c|}{X} \\ \hline
\end{tabular}
\end{table}

Note that in \gls{tls} 1.3, all of static \gls{rsa} and \gls{dh} cipher suites
have been removed: all of the \gls{pubk} exchange methods now provide \gls{pfs}.
Even though, anonymous \gls{dh} has also been removed from \gls{tls} 1.3, you can
still have unauthenticated connections by either using \textbf{raw public keys} \cite{RFC7250}
or by not verifying the certificate chain and any of it's contents.

\todo{NOTE: I did't cover specifics of how the client generates the premaster secret, etc}

The \gls{ecc}-based key exchange (\gls{ecdh} and \gls{ecdhe}) and authentication (\gls{ecdsa})
algorithms are defined in \codeword{RFC4292} \cite{RFC4292}, which is also referenced
in \codeword{RFC5246} \cite{RFC4256}. The document introduces five new
\gls{ecc}-based key exchange algorithms, all of which use \gls{ecc} to compute
the \textbf{premaster secret}, differing only in whether the negotiated
keys are epehemeral (\gls{ecdh}) or long-term (\gls{ecdhe}), as well as the mechanism (if any) used to
authenticate them. Three new \gls{ecdsa} \textbf{client authentication} mechanisms are also defined,
differing in the algorithms that the certificate must be signed with, as well
as the key exchange algorithms that they can be used with.
Those features are negotiated through the \gls{tls} Extension Mechanism.

\subsection{TLS 1.2 Handshake Protocol}


\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{img/tls-12-full-handshake.png}
\caption{\label{fig:tls-12-handshake} TLS 1.2 message flow for a full handshake}
\end{figure}


In this phase the client and the server agree on which version of the \gls{tls}
protocol to use, authenticate one to another and negotiate items like
the cipher suites and the compression method to use. Figure \ref{fig:tls-12-handshake} shows the message flow for the
full \gls{tls} 1.2 handshake. Note that \codeword{*} indicates situation-dependent
messages that are not always sent, while \codeword{ChangeCiperSpec} is a separate
protocol, rather than a message type.

As I explained before every \gls{tls} Handshake message is encapsulated within
a \gls{tls} Record. The actual Handshake message is contained within the
\codeword{fragment} of the \gls{tls} Record. The Record type for a Handshake
message is \codeword{0x16}. The Handshake message has the following structure:
a 1-byte \codeword{msg_type} field (specifies the Handshake message type),
a 2-byte \codeword{length} field (specifies the length of the \codeword{body})
and a \codeword{body} field, which contains a structure depending on the
\codeword{msh_type} (similar to \codeword{fragment} field in a \gls{tls} Record).

Now, I will describe a typical handshake message flow. I will only be mentioning
the most important field of each message.

\todo{I don't have space to put all of the structures and things sent in every
handshake message type (ex: ClientHello.session\_id)}

The connections begins with the client sending a \codeword{ClientHello}, containing
.\codeword{random}, \codeword{cipher_suites} and \codeword{compresison_methods},
among other fields.
\codeword{cipher_suites} contains a \textbf{list} of cipher suites and \codeword{compression_methods}
contains a list of compression methods (\codeword{compression_methods}) that the
client supports, ordered by preference, with the most preferred one appearing first.
The \gls{tls} Record contains a \codeword{2-byte} \codeword{version} field which
indicates the highest version supported by the client.

The server responds to the \codeword{ClientHello} with a \codeword{ServeHello}
message, which is similar in its contents, except that instead of containing
a list of supported features, it contains a single item containing the one that it chose,
\textit{i.e.}, the server responds with the chosen \codeword{cipher_suite} and
\codeword{compression_method} (note the \textbf{singular} form) that it chose from the
corresponding list sent by the client. Just like in the client's case, a \codeword{random}
is also present. The \codeword{version} field in the \gls{tls} Record indicates
the \gls{tls} version chosen by the server and it's the one that's gonna be
used for that connection.

\gls{tls} requires cryptographically secure pseudorandom values to be generated
by both of the parties independetely. Those random number (or nonces) are essential for freshness
(protection against replay attacks; we do need both randoms, otherwise the messages could
be replayed) and session uniqueness, since both of
the random values are inputs to the \textbf{master secret} generation, meaning
that a new keying material is generated with every session. If the output of the pseudorandom numbers
can be predicted by the attacker, he can predict the keying material, as described
in "A Systematic Analysis of the Juniper Dual EC Incident"\cite{DualECJu15:online}.
The \codeword{32-byte} random value is composed by concatenating the \codeword{4-byte}
GMT UNIX time with \codeword{28} cryptographically random bytes. Note that in \gls{tls} 1.3
the random number structure has the same length, but is generated in a different manner:
the client's \codeword{32 bytes} are all random, while the server's last \codeword{8 bytes}
are fixed when negotiating \gls{tls} 1.2 or 1.3.

Next, the server sends a \codeword{Certificate} message, which contains a list
of \gls{pubk} certificates (a certificate chain): the server's certificate,
every intermediate certificate and the root certificate. The certificate's contents
will depend on the negotiated cipher suite and extensions.
The same message type occurs later in the handshake if the server asks the client for certificate with the
\codeword{CertificateRequest} message. Note, that in a typical scenario, the
server will seldom request client authentication.

The \codeword{ServerKeyExchange} message follows, containing additional information
needed by the client to compute the \codeword{premaster secret}. This message
is only sent in some key exchange methods, namely \codeword{DHE_DSS}, \codeword{DHE_RSA}
and \codeword{DH_anon}. For non-anonymous key exchanges, this is the message that authenticates the server to the client,
since the server sends a digital signature over the client and server randoms
and the server's key exchange parameters. Note that this is not the only place where the
server can authenticate itself to the client. For example, if \codeword{RSA} key
exchange is used, the server authentication is done indirectly when the client
sends the premaster secret encrypted with the public RSA key provided in the
server certificate: only the server knows the corresponding private key, so if
both of the sides generate the same keying material, then the server must be who
he claims to. In \gls{tls} 1.3 this message is non existent and a similar
functionality is taken by the \codeword{key_exchange} extension.

The \codeword{ServerHelloDone} is sent to indicate the end of \codeword{ServerHello}
and associated messages. Upon the receipt of this message, the client should check
that the server provided a valid certificate. This message is not present in \gls{tls} 1.3.

With the \codeword{ClientKeyExchange} message the \codeword{premaster} secret is
set, either by direct transmission of the secret generated by the client
and encrypted with the server's public RSA key (thus, authenticating the server to the client)
or by the transmission of \gls{dh} parameters that will allow each side to generate
the same \codeword{premaster} secret independently.

The \codeword{CertificateVerify} message is sent by the client to verify its
certificate, if it has signing capability (\textit{i.e.} all certificates except for the ones
containing fixed \gls{dh} parameters).

The \codeword{ChangeCipherSpec} is its own protocol, rather than a type of handshake
message. It's sent by both parties to notify the reciever that subsequent records
will be protected under the newly negotiated \codeword{CipherSpec} and keys.

The \codeword{Finished} message is an essential part of the protocol. It's the first
message protected with the newly negotiated algorithms, keys and secrets. Only after
both parties have sent and verified the contents of this message is when they can
be sure that the Handshake has not been tampered with by a \gls{mitm} and begin to
receive and send application data. Essentially, this message contains keyed hash
with the master secret over the hash of all the data from all of the
handshake messages not including any \codeword{HelloRequest} messages and up to, but
not including, this message. The other party must perform the same computation on its
side and make sure that the result is identical to the contents of the other party's
\codeword{Finished} message. If at some point a \gls{mitm} has tampered with the
handshake, the result will be a mismatch in computed and received contents of the
\codeword{Finished} message.

At any time after a session has been negotiated, the server may send a \codeword{HelloRequest}
message, to which the client should respond with a \codeword{ClientHello}, thus
beginning the negotiation process anew.

At an point in the handshake, the Alert protocol may be used by any of the peers
to signal any problems or even abort the process by using an appropriate message type.


Besides the full handshake, the \gls{tls} 1.2 specification also specifies an
abbreviated handshake mechanism, which can be used to either resume a previous session
or duplicate one, instead of negotiating new security parameters (for example, this is useful
in the context of multiple \codeword{HTTPS} requests for various resources, when loading
a typical website). The advantage of this mechanism is that the handshake is reduced
to \codeword{1 RTT}, instead of the usual \codeword{2 RTT} as it's the case in
the full handshake. In order to do the abbreviated handshake,
the client and the server must have established a session previously, by performing
the full handshake. To do this, the clients sends a session ID of the session it wants to
resume in its \codeword{ClientHello} and its up to the server to decide if he
wants to resume that session, by responding with a \codeword{ServerHello} containing
that same session ID value, or if it wants to establish a new session by
sending a session ID with a different value. The keying material, such as the bulk
data symmetric encryption keys and the \gls{mac} keys are formed by hashing the new client
and server random values with the master secret, which means
that provided that the master secret has not been compromised and that the secure
hash operations are secure, the new connection will be secure and independent
from previous connections. The \gls{tls} 1.2 spec, suggests and upper limit
of $24$ hours for session ID lifetimes, since an attacker who obtains the master secret
will be able to impersonate the compromised party until the corresponding session
ID is retired. Note that this mechanism requires state to be maintained in both peers.

%
\subsection{DLTS}

The design of \gls{dtls} is intentionally very similar to \gls{tls}, in fact, its specification is written
in terms of differences from \gls{tls}. The changes are mostly done on the lower level,
and even extensions that have been defined before \gls{dtls} has even existed can be
used with \gls{dtls}, The latest version of \gls{dtls} is 1.2 and it's defined
in \codeword{RFC 6347}\cite{RFC6347}. There a draft of \gls{dtls} 1.3
\cite{I-D.draft-ietf-tls-dtls13} is currently in active development.

Since \gls{dtls} operates on top of an unreliable transport protocol, such as
UDP, it must explicitly deal with the absence of reliable and ordered assumptions
that are made by \gls{tls}. The main differences from \gls{dtls} 1.2 to \gls{tls} 1.2 are:

\begin{itemize}
  \item two new values are added to the record layer: an explicit \codeword{2 byte} sequence
  number and a \codeword{6 byte} epoch fields. The \gls{dtls} \gls{mac} is the same as of \gls{tls},
  however, rather than using the implicit sequence number, the \codeword{8 byte} value
  formed by concatenation of the epoch number and the sequence number is used.

  \item stream ciphers must not be used with \gls{dtls}.

  \item a stateless cookie exchange mechanism has been added to the handshake protocol
  in order to prevent \gls{dos} attacks. To accomplish this, a new handahke
  message, the \codeword{HelloVerifyRequest} has been added. After
  the \codeword{ClientHello}, the server responds with a \codeword{HelloVerifyRequest}
  containing a cookie, which is returned back to the server in another
  \codeword{ClientHello} that follows it, after which the handshake proceeds as in \gls{tls}.
  Although optional for the server, this mechanism highly recommended, and the
  client must be prepared to respond to it.

  \item the handshake message format has been extended to deal wit message reordering,
  fragmentation and loss by addition of three new fields: a message sequence field,
  a fragment offset field and a fragment length field.
\end{itemize}

\subsection{TLS Extensions}

\gls{tls} extensions were originally defined in \codeword{RFC 4366}\cite{RFC4366}
and later merged into the \gls{tls} 1.2 base spec. Each extension consists of an
extension type, which identifies the particular extension type and extension data,
which contains information specific to a particular extension.

The extension mechanism may be used by \gls{tls} clients and servers; it is backwards
compatible, which means that the communication is possible between \gls{tls} a
client that supports a particular extension and a server that does not support it,
and vice versa. A client may request the use of extensions by sending an extended \codeword{ClientHello}
message, which is just a "normal" \codeword{ClientHello} with an additional
block of data that contains a list of extensions. The backwards compatibility is achieved based on the \gls{tls}
requirement that the servers are not "extensions-aware" ignore the data
added to the \codeword{ClientHello}s that they don't understand (section \codeword{7.4.1.2} of \codeword{RFC 2246}\cite{rfc2246}),
meaning that even older servers that don't support extensions, namely the ones with
version of \gls{tls} prior to 1.2 will not "break".

The presence of extensions can be determined by checking if there are bytes
following the \codeword{compression_methods} field in the \codeword{ClientHello}.
If the server understands an extension, it sends back an extended \codeword{ServerHello},
instead of a regular one. An extended \codeword{ServerHello} is a "normal"
\codeword{ServerHello} with an additional block of data following the
\codeword{compression_method} field that contains a list of extensions.

An extended \codeword{ServerHello} message can only be sent in a response to an
extended \codeword{ClientHello} message. This prevents the possibility that an extended
\codeword{ServerHello} message could "break" older \gls{tls} clients that do not
support extensions. An extension type must not appear in the
extended \codeword{ServerHello}, unless the same extension type appeared in the
corresponding extended \codeword{CleintHello}, and if this happens, the clients must abort the handshake.

\subsection{TLS 1.3}

Due to limited space, I won't be able to describe \gls{tls} 1.3 in detail. I decided
to concentrate on \gls{tls} 1.2 instead, because \gls{tls} 1.3 is still in draft
mode and 1.2 is the latest and the recommended version in use.

Despite the protocol name not suggesting it \gls{tls} 1.3 is
very different from \gls{tls} 1.2, in fact, it should've probably been called
\gls{tls} 2.0 instead. I've studied \gls{tls} 1.3 in great detail, even ended up doing several
contributions to the \gls{tls} 1.3 specification and have been formally recognized
as a contributor. My name will be in the final document specifying \gls{tls} 1.3.
I've also participated in the mailing lists, as part of my work on the architecture of the solution.

Throughout this document, in various parts I mentioned how \gls{tls} 1.3 differs from 1.2.
A lot of the changes brought in \gls{tls} 1.3 make it more suitable in the context
of \gls{iot}. Some of those changes I've already mentioned previously in this
document, here I will add a few more. I will not go into great detail, but
will give a general overview.

The first important difference is that in \gls{tls} 1.3 extensions are required,
since some of the functionality has been moved into extensions, in order to preserve
backwards-compatibility with the previous versions of the \codeword{ClientHello}s.
In fact, the way a server distinguishes if a client is requesting a \gls{tls} 1.3
is by checking the presence of the \codeword{supported_versions} extension in the
extended \codeword{ClientHello}.

In \gls{tls} 1.3 more data is encrypted and the encrytion starts earlier. For example,
on the server-side you have a notion of "encrypted extensions". The \codeword{EncryptedExtensions}
message, as the name suggests, contains a list of extensions that are encrypted
under a symmetric key and it contains any extensions that are not needed
to establish the cryptographic context.

In \gls{tls} 1.3, non \gls{aead} ciphersuites are not supported anymore.
Static RSA and \gls{dh} ciphersuites have been removed, meaning that all
public key exchange mechanisms now provide \gls{pfs}. Even though
anonymous \gls{dh} key exchange has been removed, you can still have
unauthenticated connections by either using raw public keys or not verifying the
certificate and any of its contents.

One of the main problems with using \gls{tls} in \gls{iot} is that while \gls{iot}
traffic need to be quick and lightweight, \gls{tls} 1.2 adds two additional
round trips (\codeword{2 RTT}) to the start of every session. \gls{tls} 1.3 handshake has less latency,
when compared to \gls{tls} 1.2 and this is extremely important in the context of \gls{iot}.
The full \gls{tls} 1.3 handshake is only \codeword{1 RTT}. \gls{tls} 1.3 even allows
clients to send data on the first flight (known as "early data"), when the clients
and servers share a \gls{psk} (either obtained externally or via a previous handshake).
This means that in \gls{tls} 1.3 you can have \codeword{0-RTT} data. Session resumption
via identifiers and tickets has been obsoleted in \gls{tls} 1.3, and both methods
have been replaced by a \gls{psk} mode. The \gls{psk} is established on a previous
connection after the handshake is completed and can be presented by the client
on the next visit.


\section{Proposed Solution}
\todo{STILL TODO (max 3 pages) Below is a draft, a brainstorm of sentences}

I will use the extension mechanism to specify a profile for a lightweight
communication. The extension will be designed in such a way that the number
of exchanged messages is limited to a minimum. This extension(s) can eventually
be used to even negotiate the header compression as described in \cite{6LoWPANC53:online}.
Extensions can change what they want, as confirmed by one of the TLS designers,
when I asked him the question: https://www.ietf.org/mail-archive/web/tls/current/msg24932.html

%
% ---- Bibliography ----
%
\nocite{*}
\bibliographystyle{splncs03}
\bibliography{tls_for_iot,papers}
%
\printglossary[style=long]
%
\end{document}
