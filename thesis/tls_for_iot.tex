% This is the file where my Master Thesis will be written. It uses the adapted
% LNCS Template.
%
% I'll be using a few codes in the comments, which can be easily looked up:
% * NOTE: theseis-text related comments
% * TODO: thesis-related TODO's
% * WARN: latex/formatting-related warningss
%
% WARN: for running head, subsititute the line below by:
% \documentclass[runningheads,a4paper]{llncs}
\documentclass{llncs}

\usepackage[justification=justified]{caption}
\usepackage{geometry}

%\usepackage[group-separator={,}]{siunitx}k
\usepackage{numprint}

\geometry{
a4paper,         % or letterpaper
textwidth=13.7cm,  % llncs has 12.2cm
textheight=19.9cm, % llncs has 19.3cm
heightrounded,   % integer number of lines
hratio=1:1,      % horizontally centered
vratio=2:3,      % not vertically centered
}
%
%%% WARN: custom extension
%\usepackage{xcolor}
\usepackage[table,xcdraw]{xcolor}
\usepackage{multirow}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}
%%% GLOSSARIES
\usepackage{glossaries}

%%% inline code
\usepackage{xparse}
\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

%%% figures
\usepackage{graphicx}
\usepackage{wrapfig}

%%% tables
\usepackage{booktabs}

\usepackage{amssymb}

\usepackage{url}
\def\UrlBreaks{\do\/\do-}


\makeglossaries

\newacronym{tls}{TLS}{Transport Layer Security}%
\newacronym{ssl}{SSL}{Secure Sockets Layer}%
\newacronym{ietf}{IETF}{Internet Engineering Task Force}%
\newacronym{mac}{MAC}{Message Authentication Code}%
\newacronym{psk}{PSK}{Pre-Shared Key}%
\newacronym{rpk}{RPK}{Raw Public Key}%
\newacronym{aead}{AEAD}{Authenticated Encryption With Associated Data}%
\newacronym{pkc}{PKC}{Public Key Cryptography}%
\newacronym{hmac}{HMAC}{Hash-Based Messaage Authentication Code}%
\newacronym{hkdf}{HKDF}{HMAC-based Extract-and-Expand Key Derivation Function}%
                             \newacronym{html}{HTML}{Hypertext Markup Language}%
\newacronym{https}{HTTPS}{Hypertext Transfer Protocol Secure}%
\newacronym{ecc}{ECC}{Elliptic Curve Cryptography}%
\newacronym{iv}{IV}{Initialization Vector}%
\newacronym{ecdh}{ECDH}{Elliptic Curve Diffie-Hellman}%
\newacronym{ecdhe}{ECDHE}{Elliptic Curve Diffie-Hellman Ephemeral}%
\newacronym{ecdsa}{ECDSA}{Elliptic Curve Digital Signature Algorithm}%
\newacronym{rfc}{RFC}{Request For Comment}%
\newacronym{prf}{PRF}{Pseudo-Random Function}%
\newacronym{rsa}{RSA}{Rivest-Shamir-Adleman}%
\newacronym{dh}{DH}{Diffie-Hellman}%
\newacronym{pms}{PMS}{premaster secret}%
\newacronym{dsa}{DSA}{Digital Signature Algorithm}%
\newacronym{pfs}{PFS}{Perfect Forward Secrecy}%
\newacronym{mitm}{MITM}{Man In The Middle}%
\newacronym{ac}{AC}{Asymmetrical Cryptography}%
\newacronym{sc}{SC}{Symmetrical Cryptography}%
\newacronym{iot}{IoT}{Internet Of Things}%
\newacronym{dtls}{DTLS}{Datagram TLS}%
\newacronym{tlsd}{(D)TLS}{(D)TLS}%
\newacronym{coap}{CoAP}{Constrained Application Protocol}%
\newacronym{ec}{EC}{Elliptic Curve}%
\newacronym{sca}{SCA}{Side-Channel Attack}%
\newacronym{ocsp}{OCSP}{Online Certificate Status Protocol}
\newacronym{crl}{CRL}{Certificate Revocation List}
\newacronym{ca}{CA}{Certification Authority}
\newacronym{sni}{SNI}{Server Name Indication}
\newacronym{dos}{DoS}{Denial-of-Service}
\newacronym{ddos}{DDoS}{Distributed Denial-Of-Service}
\newacronym{pki}{PKI}{Public Key Infrastructure}
\newacronym{ae}{AE}{Authenticated Encryption}
\newacronym{nsa}{NSA}{US National Security Agency}
\newacronym{apk}{APK}{Authorized Public Key}
\newacronym{iana}{IANA}{Internet Assigned Numbers Authority}
\newacronym{jit}{JIT}{just-in-time}
\newacronym{ir}{IR}{Intermediate Representation}

\glsunset{tlsd}


%%% WARN: added as specified here:
% https://tex.stackexchange.com/questions/272200/table-of-contents-showing-the-title-as-only-entry-latex
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{} % removes author name from TOC
\renewcommand*\l@title[2]{} % removes title name from TOC
\makeatletter
%%%
%
\usepackage{makeidx}  % allows for indexgeneration
%
\newcounter{footnotesintable}
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\addtocmark{TLS For IoT} % additional mark in the TOC

\tableofcontents
\newpage

\mainmatter              % start of the contributions
%
\title{Transport Layer Security Protocol For Internet Of Things}
%
\titlerunning{TLS For IoT}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{{Illya Gerasymchuk} \\
\email{illya@iluxonchik.me}}
%
\authorrunning{Illya Gerasymchuk} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Illya Gerasymchuk}
%
\institute{Instituto Superior Tecnico}
% WARN: supper hacked-in
\supervisors{Ricardo Chaves, Aleksandar Ilic}
\maketitle              % typeset the title of the contribution

\begin{abstract}
\gls{tls} is one of the most used communication security protocols in the world. It comes with many configurations. 
Each configuration offers a set o security services, which has an implication on the 
security level and computational cost.
Not all of those configurations can be used with the resource constrained \gls{iot} devices, due to the
high computational and memory demands. Most of the existing work focuses on \gls{dtls}
and cannot be easily integrated with existing deployments. Existing work fails
to evaluate the cost of various \gls{tls} configurations and its security services.
This work focuses on cost analysis of the security services of the TLS protocol.
We evaluate the number of CPU cycles used by the TLS configurations
and by each individual security service. Software developers can use this information
to make security/cost trade-offs based on the environment needs and limitations.  

\keywords{TLS, DTLS, SSL, IoT, cryptography, protocol, lightweight cryptography}
\end{abstract}
%

\section{Introduction}
%

In recent years there has been a sharp increase in the number of IoT
devices and this trend is expected to continue\cite{IoTnumb83:online}. The IoT is a network
of interconnected devices, which exchange data with one another over
the internet. In fact, it can be any object that has an assigned
IP address and is provided with the ability to transfer data over a network. 
While there are many types of IoT devices, all of them
are restricted: they have limited memory, processing power and
available energy. Examples of IoT devices include temperature sensors,
smart light bulbs and physical activity trackers.
Even a salt shaker\cite{SMALTThe76:online} can now be part of the global network.

The \gls{iot} technology provides many benefits, from personal comfort to
transforming entire industries, mainly due to increased connectivity and
new sources for data analysis. The technological development, however, tends to focus on
innovative design rather than on security. \gls{iot} devices frequently
connect to networks using inadequate security and are hard to update when
vulnerabilities are found.

This lack of security in the \gls{iot} ecosystem has been exploited by the
the \textit{Mirai} botnet\cite{sec17ant94:online} when it overwhelmed several high-profile
targets with massive \gls{ddos} attacks. This is the most devastating attack involving \gls{iot}
devices done to date. However, the \textit{Reaper} botnet\cite{ReaperCa10:online} could be
even worse if it is ever put to malicious use. Similar attacks will inadvertently
come in the future.

In the process of the work on this dissertation, we have made several
contributions to the \gls{tls} $1.3$ specification, and were formally recognized as 
contributors\cite{Mergepul65:online}. Our name can be found in the document specifying \gls{tls} $1.3$\cite{RFC8446}.
Although to the lesser extent, we have also contributed to \gls{dtls} $1.3$ specification\cite{DTLS13:online}.
We have found a security issue within the
\gls{tls} implementation of the \textit{mbedTLS} library. We reported it and it
has been assigned a \textit{CVE} with the id \textit{CVE-2018-1000520}\cite{NVDCVE2094:online}.
It is an authentication problem, where certificates signed with an incorrect algorithm
were accepted in some cases. More specifically, \textit{ECDH(E)-RSA} ciphersuites allowed \gls{ecdsa}-signed
certificates, when only \gls{rsa}-signed ones should have been. We also found a bug in \textit{mbedTLS}'s test suite
related to the use of deprecated \textit{SHA-1}-signed certificates and submitted a code fix to 
it\cite{sslserve89:onelin}\cite{updatete23:online}.

\subsection{Motivation}
%

While inter-device communication has numerous benefits, it is important
to ensure the security of that communication. For example, when you log
in to your online banking account, you do not want others to be
able to see your password, as this may lead to the compromise of your
account. Having your account compromised means that a malicious entity
might steal your money. Similarly, when you are transferring funds via
online banking, you want the contents of that operation to be
invisible to an observer, for privacy reasons. It is also desirable
that no party is able to tamper with the data en transit,
as it may lead to undesired consequences, such as the transfer of a
larger amount than intended. Proper communications security allows
those goals to be achieved.

\gls{tls} is one of the most used protocols for communication security. It
powers numerous technologies, such as \gls{https}. TLS offers the
security services of authentication, confidentiality, privacy, integrity, replay
protection and perfect forward secrecy. It is not a requirement to use all of
those services for every TLS connection. The protocol is similar to
a framework, in the sense that you can enable individual security
services on a per-connection basis. For example, when you are downloading
software updates, while data confidentiality is probably not a concern,
data authenticity and integrity, are. In \gls{tls}, it is possible for a connection
to only offer authenticity and integrity, without offering confidentiality.
Foregoing unnecessary services will lead to a smaller resource usage,
which in turn leads to smaller execution time and power usage. This
is especially important in the context of IoT, due to the constrained
nature of the devices. 

Existing work does not explore the computational costs
of the security services available in \gls{tls}. Examples of such costs are the 
number of CPU cycles executed, time taken and power used.  
Thus, developers wishing to deploy the \gls{tls} protocol
in constrained environments do not have a resource that would help them in choosing a \gls{tls}
configuration appropriate to the environment's needs and limitations.

\gls{tls} is designed to run on top of a reliable, connection-oriented
protocol, such as TCP. \gls{dtls} is the version of \gls{tls} that runs on top
of an unreliable transport protocol, such as UDP. Most \gls{iot} devices have
very limited processing power, storage and energy. Moreover, the performance of
TCP is known to be inefficient in wireless networks, due to its congestion control
algorithm. This situation is worsened with the use of low-power radios and lossy
links found in sensor networks. Therefore, in many cases the use of TCP with \gls{iot}
is not the best option. For this reason, \gls{dtls}, which runs on top
of UDP, is used more frequently in such devices. 
While the work of this dissertation will be focused on \gls{tls}, the majority of it
can also be applied to \gls{dtls}. This is a consequence of \gls{dtls} being 
just an adaption of \gls{tls} over unreliable  transport protocols, 
without changes to the core protocol.

There are numerous IoT devices, each one with different hardware
capabilities and security requirements. For example, some IoT
devices have the resources to use public key cryptography,
while for others symmetric cryptography is the only option.
In some cases, the communicating devices require data authenticity, confidentiality
and integrity (e.g. when logging in into a device), while in others data
authenticity and integrity is enough (e.g. when transferring updates).

\gls{tls} was not designed for the constrained environment of IoT. Despite that,
it is a malleable protocol and can be configured to one's needs. In essence,
it is a combination of various security algorithms that together form
a protocol for communication security. If configured
properly, it is possible to use it in the context of IoT.

The majority of existing work on \gls{tlsd} optimization proposes 
a solution that is either tied to a
specific protocol, such as \gls{coap}, or requires an introduction of a third-party
entity, such as the trust anchor in the case of the S3K system\cite{S3KScala62:online} or
even both. This has two main issues. First, a protocol-specific solution cannot
be easily used in an environment where (D)\gls{tls} is not used with that protocol.
Second, the requirement of a third-party
introduces additional cost and complexity, which will be a big resistance factor
in adopting the technology. This is especially true for developers working on
personal projects or projects for small businesses, leaving the communications insecure
in the worse case scenario. Therefore a solution that is protocol independent and fully 
compatible with the \gls{tlsd} standard and existing infrastructure is desired.

Another issue with the existing literature is that it almost exclusively focuses on \gls{dtls} optimization
and not all of it can be applied to \gls{tls}. Herein we want to further explore \gls{tls} optimization. 
There is clearly a need for that,
especially with \gls{coap} over TCP and \gls{tls} standard\cite{I-D.ietf-core-coap-tcp-tls} being currently developed. The
mentioned standard does not explore any \gls{tls} optimizations, and since any
\gls{iot} device using it in the future would benefit from them, this is an important
area to explore.

\subsection{Objectives}

(D)\gls{tls} is a complex protocol with numerous possible configurations. Each configuration
provides different set security services and a different security level. This has a direct
impact on the resource usage. Thus, the cost of a \gls{tlsd} connection can be lowered,
by using an appropriate configuration. Typically, this involves making security/cost trade-offs.
Optimizing the connection cost by selecting one of the numerous configurations available in \gls{tlsd}
 meets our goals of being protocol independent, fully compatible with
existing infrastructure and targeting \gls{tls} optimization specifically.

The objective of this work is to provide a means of assisting application developers
who wish to include secure communications in their applications to make
security/resource usage trade-offs, according to the environment's needs
and limitations. In order to achieve this goal, the cost of each individual security service
will be evaluated. With this information, the programer will be able to choose a configuration that
meets his security requirements and device constraints. If the limitations of the device's hardware
do not allow to meet the requirements, the programer may decide on an alternative configuration, possibly with
a loss of some security services and a lower security level, or forgo using (D)\gls{tls} altogether.
Thus, this work is targeted towards developers and InfoSec professionals who wish to add communication security
to applications in the IoT environment.

In our work, we evaluated the \textit{mbedTLS 2.7.0}'s\cite{SSLLibra13:online} implementation of the \gls{tls} protocol version $1.2$.
\textit{mbedTLS} is among the most popular libraries with a \gls{tls} implementation for embedded systems. \gls{tls} protocol 
version $1.2$ is currently the most used version of \gls{tls} on the internet \cite{QualysSS90:online}. The work on
the dissertation started before \gls{tls} protocol's version $1.3$ specification was finished and there were no embedded device
libraries which implemented it.  For this reason we did not evaluate \gls{tls} 1.3. Despite that, the results
obtained in this work apply to it as well, since the core functionality of the security services remained mostly unchanged.

The cost metric that we used is the number of CPU cycles. The profiled instructions are CPU-bound, thus
the number of CPU cycles will be proportional to time. To be more precise, we will measure an estimate of 
the number of CPU cycles. Section \ref{sec:eval-metrics-and-lims} contains a detailed description of the evaluated costs 
and its limitations.

\subsection{Results}

In summary, the results of this work are enumerated as follows:

\begin{enumerate}
  \item Evaluate the costs of the security services of confidentiality, integrity, \gls{pfs} and authentication in \gls{tls}
  \item Evaluate and compare the costs of various alternative algorithms which can be used to provide each one of the security services
  \item Evaluate and compare the costs of all of the possible \gls{tls} configurations present in \textit{mbedTLS 2.7.0}
  \item Contribute to the \gls{tls} protocol's version $1.3$ specification
  \item Contribute to the \gls{dtls} protocol's version $1.3$ specification
  \item Find and report a security vulnerability present in \textit{mbedTLS 2.7.0}
  \item Find, report and submit a patch to fix a bug present in \textit{mbedTLS 2.7.0}
\end{enumerate}

\subsection{Structure of The Document}

The document is organized as follows: Section 2 describes the background. It
introduces some of the concepts that will be used throughout
the document. Section 3 describes the \gls{tls} and \gls{dtls} protocol
versions $1.2$ and $1.3$, with a focus on the version $1.2$ since
it is the latest and the most used version of the protocol (version $1.3$ is still in
draft mode). Section 4 describes all of the related work done in the area and
the current state of the art. Section 5 describes the objectives of the work and evaluation 
are described in more detail. 
Section 6
covers the evaluation's methodology and limitations. In Section 7 we evaluate the costs of the various \gls{tls}
configurations and their individual parts. Finally, the conclusion of the work is done in Section 8.

\section{Background}

\gls{tls} is a complex protocol that relies on various concepts to provide
security. The most relevant ones will be described here.

In a typical scenario, \gls{tls} uses \gls{ac} for peer authentication and \gls{sc} for bulk data
encryption and integrity protection, for this reason this topic will be covered in Section \ref{sac}. Section \ref{pccc} covers the most common way of peer authentication: public key certificates. Authenticated Encryption With Additional Data (AEAD) ciphers offer various advantages in the
context of \gls{iot}, particularly less computational and spacial overhead.
Furthermore, they are the only type of ciphers that can be used in \gls{tls}
$1.3$. For those reasons, they're covered in Section \ref{aeadciphers}.
When compared to other public key cryptography approaches, \gls{ecc} offers shorter keys, lower processing requirements and lower memory usage for equivalent security strength, being heavily used
in \gls{tls}. An overview of \gls{ecc} in presented in Section \ref{eccsection}.


\subsection{Symmetric vs Asymmetric Cryptography} \label{sac}

\gls{ac} is more expensive than \gls{sc} in terms of performance. There are two main reasons for this. First, larger key sizes are required for an \gls{ac} system to achieve the
same level of security as in a \gls{sc} system. Second, \codeword{CPU}s are slower at performing the underlying
mathematical operations involved in \gls{ac}, namely exponentiation requires
$O(log e)$ multiplications for an exponent $e$. The 2016 \codeword{NIST} report \cite{Recommen44:online}
suggests that an \gls{ac} algorithm would need to use a secret key with size of \codeword{15360 bits}
to have equivalent security to a \codeword{256-bit} secret key for a \gls{sc} algorithm.
This situation is ameliorated by \gls{ecc}, which requires keys of \codeword{512 bits}, but
it is still slower than using \gls{sc}. The 2017 \codeword{BSI} report \cite{Kryptogr1:online} (from the
German federal office for information security) suggests similar numbers.

Another argument for avoiding the use of \gls{ac}
algorithms as much as possible, is that they require additional storage space. This can be a problem for many \gls{iot} devices,
like \codeword{class 1} devices according to the terminology of constrained-code
networks\cite{RFC7228} which have approximately \codeword{10KB} of RAM and \codeword{100KB}
of persistent memory. We measured and compared the resulting size of the \textit{mbedTLS 2.7.0} library\cite{SSLLibra13:online} binary when it was compiled with and without the \gls{rsa} module
(located in the \codeword{rsa.c} file). The conclusion is that that using the \codeword{rsa.c} module adds an overhead of about \codeword{32KB}.

\subsection{Public Certificates and Certificate Chains} \label{pccc}

A public key certificate, also known as a digital certificate, is an electronic
document used to prove the ownership of a public key. This allows other parties
to rely upon assertions made by the private key that corresponds to the public key
that is certified. In the context of (D)\gls{tls}, certificates serve as a guarantee
that the communication is done with the claimed entity and not someone impersonating it.

A \gls{ca} is an entity that issues digital certificates. There are two types of
\gls{ca}s: the \textbf{root \gls{ca}s} and the \textbf{intermediate \gls{ca}s}.
An intermediate \gls{ca} is provided with a certificate with signing capabilities
signed by one of the root \gls{ca}s. A \textbf{certificate chain} is a list of
certificates from the root certificate to the end-user certificate, including
any intermediate certificates along the way. In order for a certificate
to be trusted by a device, it must be directly or indirectly issued by a \gls{ca} trusted by the device.

In (D)\gls{tls}, the certificates are in the \codeword{X.509} format, defined
in \codeword{RFC 5280}\cite{rfc5280}.

\subsection{\gls{aead} Ciphers} \label{aeadciphers}

\gls{ae} and \gls{aead} are forms of encryption which simultaneously provide
confidentiality, integrity and authenticity guarantees on the data. An \gls{ae}
cipher takes as input a \codeword{key}, a \codeword{nonce} and a \codeword{plaintext}
and outputs the pair \codeword{(ciphertext, MAC)}, if it is encrypting and does the inverse
process, while also performing the \gls{mac} check if it is decrypting.

\gls{aead} is nothing more than a variant of \gls{ae}, which comes with an extra
input parameter that is additional data, that is \textbf{only authenticated, but not encrypted}.
Some \gls{aead} ciphers have shorter authentication tags (\textit{i.e.} shorter \gls{mac}s),
which makes then more suitable for low-bandwidth networks, since the messages to be sent are smaller in size.

\subsection{\gls{ecc}} \label{eccsection}

public key cryptography is based on the use of one-way math functions. Such
functions make it easy to compute the answer given an input,
but hard to compute the input given the answer. For example, RSA uses factoring
as the one one way function: it is easy to multiply large numbers, but it is hard
to factor them.

\gls{ecc} is based on elliptic curves, which are set of points $(x,y)$ that are
solutions to the equation $y^2 = x^3 + ax + b$, where $4a^3 + 27b^2 \neq 0$.
Depending on the value of $a$ and $b$, elliptic curves assume different shapes
on the plane.

The security of \gls{ecc} is based on the elliptic curve discrete logarithm
problem. It states that scalar multiplication is a one way function. To exemplify,
given a curve $E(\mathbb{Z}/p\mathbb{Z})$ and points $Q$ and $P$ on that curve
$Q,P \in E(\mathbb{Z}/p\mathbb{Z})$, where $Q$ is a multiple of $P$, the elliptic curve discrete logarithm problem
states that finding the integer $k$, such that $Q=kP$ is a very hard problem.

\section{The \gls{tls} Protocol}

\gls{tls} is a \textbf{client-server} protocol
that runs on top a \textbf{connection-oriented and reliable transport protocol},
such as \textbf{TCP}. Its main goal is to provide \textbf{privacy} and \textbf{integrity}
between the two communicating peers. Privacy implies that a third party will not
be able to read the data, while integrity means that a third party will not be
able to alter the data.

In the TCP/IP Protocol Stack, \gls{tls} is placed between the \textbf{Transport}
and \textbf{Application} layers. It is designed to simplify the establishment
and use of secure communications from the application developer's standpoint.
The developer's task is reduced to creating a "secure" connection (\textit{i.e.} socket), instead of a "normal" one.

A secure communication established using \gls{tls} has two phases. In the first
phase, the communicating peers authenticate one to another and negotiate the parameters, such as the secret keys and the encryption algorithm. In the
second phase, they exchange cryptographically protected data under
the previously negotiated parameters. The first phase is done under the
Handshake Protocol and the second under the Record Protocol. In order to
achieve its goals, during the Handshake Protocol the client and the server
exchange various messages. The message flow is depicted in Figure \ref{fig:tls-12-handshake} and described in more detail in Section
\ref{hsp}.

\gls{tls} provides the following \textbf{security services}:
\begin{itemize}
\item \textbf{authentication} - both, \textbf{peer entity} and \textbf{data origin} (or \textbf{integrity})
authentication.
\subitem \textbf{peer entity authentication} - a peer has a guarantee that it is talking to certain entity, for example, \codeword{www.google.com}.
This is achieved thought the use of \gls{ac}, also known as \gls{pkc}, (\textit{e.g.} \codeword{RSA} and \codeword{DSA})
or \textbf{symmetric key cryptography}, using a \gls{psk}.
\item \textbf{confidentiality} - the data transmitted between the communicating
entities (the client and the server) is encrypted. Symmetric cryptography is
used for data encryption (\textit{e.g.}, \codeword{AES}).
\item \textbf{integrity} (also called \textbf{data origin authentication}) - a peer can be sure that the data was not modified or forged,
\textit{i.e.}, there is a guarantee that the received data is coming from the expected entity. For example, a peer can be sure
that the \codeword{index.html} file that was sent to when it connected to \codeword{www.google.com} did, in fact,
come from \codeword{www.google.com} and it was not tampered with by an attacker (\textbf{data integrity}). This is achieved either through the use
of a keyed \gls{mac} or an \gls{aead} cipher.
\item \textbf{replay protection} (also known as \textbf{freshness}) -
a peer can be sure that a message has not been replayed. This is
achieved through the use of sequence numbers. Each \gls{tls} record has a different sequence number, which is incremented. If a non-\gls{aead} cipher is used, the sequence number is a direct input of the \gls{mac} function. If an \gls{aead} cipher is used, a nonce derived from the sequence number is used as input to that cipher.
\end{itemize}

Despite using \gls{pkc}, \gls{tls} does \textbf{not} provide \textbf{non-repudiation services}:
neither \textbf{non-repudiation with proof of origin}, which addresses the peer denying
the sending of a message, nor \textbf{non-repudiation with proof of delivery}, which
addresses the peer denying the receipt of a message. This is due to the fact that
instead of using \textbf{digital signatures}, either a keyed \gls{mac} or an \gls{aead}
cipher is used, both of which require a secret to be \textbf{shared} between the peers.

It is not required to use all of the tree security services every situation.
In this sense, \gls{tls} is like a framework that allows to select which security services should be used for a communication session. As an example,
certificate validation might be skipped, which means that the \textbf{authentication} guarantee is not provided. There are some differences regarding this claim between \gls{tls} $1.2$\cite{RFC5246}
and \gls{tls} $1.3$. For example, while in the first there is a \codeword{null}
cipher (no authentication, no confidentiality, no integrity), in the latter
this is not true, since it deprecated all non-\gls{aead} ciphers in favor of
\gls{aead} ones.

The terms \gls{ssl} and \gls{tls} are often used interchangeably, but one is
a predecessor of another - \gls{ssl} $3.0$\cite{RFC6101} served as the basis
for \gls{tls} $1.0$\cite{RFC6101}.

Section \ref{subprotocols} will begin with a brief overview of the various sub-protocols that compose \gls{tls}. The \gls{tls} Record Layer will
be described in sufficient detail for the \gls{tls} Handshake Protocol
description that follows in Section \ref{hsp}. The way each record is
processed when sending and receiving data is covered in Section \ref{record}.
The symmetric keys involved in cryptographic operations that provide
confidentiality and security are described in Section \ref{keying}. Section
\ref{keying-material} explains how those keys are generated in \gls{tls} 1.2.
There are various methods that the client and the server can use to exchange
keys, those will be covered in Section \ref{key-exchange}. The \gls{tls}
Extension mechanism will be covered in Section \ref{extensions}. There
are various differences from \gls{tls} $1.2$ to $1.3$ and those that were
not covered in the previous sections will be in Section \ref{tls-13}.
This section ends with an outline of the main differences from \gls{dtls} to \gls{tls} in Section \ref{dtls}.


\subsection{\gls{tls} (Sub)Protocols} \label{subprotocols}

\gls{tls} is composed of several protocols, which are illustrated in Figure
\ref{fig:tls-subprotocols} and briefly described below:
\begin{itemize}
  \item \textbf{\gls{tls} Record Protocol} - the lowest layer in \gls{tls}.
  It takes messages to be transmitted, fragments the data into manageable
  blocks, optionally compresses them, encrypts them and transmits the result.
  When the data is received, the reverse process is done. The \gls{tls}
  Record Protocol is located directly on top of \textbf{TCP/IP} and it serves as an
   \textbf{encapsulation for the remaining sub-protocols} (\codeword{4} in case of \gls{tls} 1.2
   and \codeword{3} in case of \gls{tls} 1.3). To the  \textbf{Record Protocol},
   the remaining sub-protocols are what \codeword{TCP/IP} is to \codeword{HTTP}.
   A \gls{tls} Record is comprised of 4 fields, with the first 3 comprising the
   \gls{tls} Record header. The first field is a 1-byte record \codeword{type}
   specifying the type of record that is encapsulated (ex: value \codeword{0x16}
   for the handshake protocol). The second is a 2-byte \codeword{TLS version} field. The third is a
   2-byte \codeword{length} field specifying the length of the data in the record, excluding
   the header itself (this means that \gls{tls} has a maximum record size
   of \codeword{16384} bytes). The fourth is a \codeword{fragment} field,
   containing \codeword{length} bytes of data that is
   transparent to the Record layer and should be dealt by a higher-level protocol. That higher-level protocol is specified by the \codeword{type} field. This is illustrated in Figure \ref{fig:tls-record-header}.
  \item \textbf{\gls{tls} Handshake Protocol} - the core protocol of \gls{tls}.
  It allows the communicating peers to \textbf{authenticate} one to another and to negotiate the connection state. In \gls{tls} 1.2
  a \textbf{cipher suite} and a \textbf{compression} method are negotiated. In \gls{tls} $1.3$, a \textbf{cipher suite} and a \textbf{key exchange} algorithm are negotiated. The agreed upon \textbf{cipher suite} is used to provide the previously described security services. In
  \gls{tls} $1.2$, a \textbf{cipher suite} consists of a \textbf{cipher spec},
  a \textbf{key exchange} algorithm and a \gls{prf}, which is used for key generation.
  In \gls{tls} $1.2$,
  \textbf{cipher spec} defines the message encryption algorithm and the message
  authentication algorithm. In \gls{tls} 1.3, the term
   \textbf{cipher spec} is no longer present, since the \textbf{ChangeCipherSpec}
   protocol has been removed. The concept of \textbf{cipher suite} has been updated
   to define the pair consisting of an \gls{aead} algorithm and a hash function to be used with
   \gls{hkdf}. In \gls{tls} $1.3$ the \textbf{key exchange} algorithm is negotiated via
   extensions.
  \item \textbf{\gls{tls} Alert Protocol} - allows the communicating peers to
  signal potential problems.
  \item \textbf{\gls{tls} Application Data Protocol} - used to transmit application data messages securely using the security parameters negotiated during the \textbf{Handshake Protocol}. The messages are treated as transparent data to the record layer.
  \item \textbf{\gls{tls} Change Cipher Spec Protocol} (removed in \gls{tls} 1.3) -
  used to activate the initial \textbf{cipher spec} or change it during the connection.
\end{itemize}

% src: https://tex.stackexchange.com/questions/5769/two-figures-side-by-side

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/record-header-3.png} % first figure itself
  \caption{\label{fig:tls-record-header} TLS Record header}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{img/tls-sub-protocols-3.png} % second figure itself
\caption{\label{fig:tls-subprotocols} TLS (Sub)protocols and Layers}
\end{figure}

\subsection{TLS 1.2 Handshake Protocol} \label{hsp}

The Handshake Protocol is responsible for negotiating a \textbf{session},
which will then be used in a \textbf{connection}.
There is a difference between a \gls{tls} session and a \gls{tls} connection:
\begin{itemize}
  \item \textbf{TLS session} - association between two communication peers that is
  created by the \textbf{TLS Handshake Protocol}, which defines a set of negotiated parameters
  (cryptographic and others, such as
  the compression algorithm, depending on the \gls{tls} version) that are used by the \textbf{TLS connections associated
  with that session}. A single \textbf{TLS session} can be shared among multiple
  \textbf{TLS connections} and its main purpose is to avoid the expensive negotiation
  of new parameters for each \textbf{TLS connection}. For example, let us say
  that a \gls{html} page is being downloaded over the \gls{https} and that page references some images from that same server using \gls{https} links. Instead of the web browser negotiating a new \gls{tls} session for every single image again, it can re-use the the
  one it has established to download the \gls{html} page,
  saving time and computational resources. Session resumption can be done using various
  approaches, such as \textbf{session identifiers}, described throughout \codeword{Section 7.4}
  of \codeword{RFC 5246}\cite{RFC5246} and \textbf{session tickets}, defined in
  \codeword{RFC 5077}\cite{RFC5077}.
  \item \textbf{TLS connection} - used to actually transmit the cryptographically
  protected data. For the data to be cryptographically protected, some parameters,
  such as the secret keys used to encrypt and authenticate the transmitted
  data need to be established; this is done when a \textbf{TLS session} is created,
  during the \textbf{TLS Handshake Protocol}.
\end{itemize}

\begin{figure}
        \centering
        \includegraphics[width=0.9\textwidth]{img/tls-12-full-handshake2.png} % first figure itself
        \caption{\label{fig:tls-12-handshake} \gls{tls} $1.2$ message flow for a full handshake}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/dtls-cookie.png} % second figure itself
  \caption{\label{fig:dtls-cookie} DTLS handshake with HelloVerifyRequest containing the cookie}
\end{figure}


In the handshake phase the client and the server agree on which version of the \gls{tls}
protocol to use, authenticate one to another and negotiate session state items like
the cipher suite and the compression method.  Figure \ref{fig:tls-12-handshake} shows the message flow for the
full \gls{tls} $1.2$ handshake. \codeword{*} indicates situation-dependent
messages that are not always sent. \codeword{ChangeCiperSpec} is a separate
protocol, rather than a message type.

As already mentioned, every \gls{tls} handshake message is encapsulated within
a \gls{tls} record. The actual handshake message is contained within the
\codeword{fragment} of a \gls{tls} record. The record type for a handshake
message is \codeword{0x16}. The handshake message has the following structure:
a 1-byte \codeword{msg_type} field (specifies the Handshake message type),
a 2-byte \codeword{length} field (specifies the length of the \codeword{body})
and a \codeword{body} field, which contains a structure depending on the
\codeword{msg_type} (similar to \codeword{fragment} field in a \gls{tls} record).

A typical handshake message flow will be described next, with only the most important fields of each message mentioned.

The \gls{tls} handshake starts with the client sending a \codeword{ClientHello}, containing \codeword{random}, \codeword{cipher_suites} and \codeword{compressison_methods},
among other fields.
\\\codeword{cipher_suites} contains a \textbf{list} of cipher suites and \codeword{compression_methods}
contains a \textbf{list} of compression methods that the
client supports, \textbf{ordered by preference}, with the most preferred one appearing first.
The \gls{tls} record contains a $2$-byte \codeword{version} field which
indicates the highest version supported by the client.

The server responds to the \codeword{ClientHello} with a \codeword{ServeHello}.
This message is similar, but contains the chosen \codeword{cipher_suite}
and \codeword{compression_method} from the list sent by the client. Just like in the client's case, a \codeword{random}
is present. The \codeword{version} field in the \gls{tls} record indicates
the \gls{tls} version chosen by the server, which will be the one used for
that connection.

\gls{tls} requires cryptographically secure pseudorandom numbers to be generated
by both of the parties independently. Those random numbers (or \textit{nonces}) are essential for freshness
(protection against replay attacks) and session uniqueness. To provide those
properties, both of the random values are required. Those two random values are inputs to the \gls{prf} when the master secret is generated, meaning
that a new keying material will be obtained with every new session. If the output of the pseudorandom number generator
can be predicted by the attacker, he can predict the keying material, as described
in "A Systematic Analysis of the Juniper Dual EC Incident"\cite{DualECJu15:online}.
The \codeword{32-byte} random value is composed by concatenating the \codeword{4-byte}
GMT UNIX time with \codeword{28} cryptographically random bytes. Note that, in \gls{tls} $1.3$,
the random number structure has the same length, but is generated in a different manner:
the client's \codeword{32 bytes} are all random, while the server's last \codeword{8 bytes}
are fixed when negotiating \gls{tls} $1.2$ or $1.3$.

Next, the server sends a \codeword{Certificate} message, which contains a list
of public key certificates: the server's certificate,
every intermediate certificate and the root certificate, \textit{i.e}, a certificate chain. The certificate's contents
will depend on the negotiated cipher suite and extensions.
The same message type occurs later in the handshake, if the server requests the client's certificate with the
\codeword{CertificateRequest} message. In a typical scenario, the
server will not request client authentication.

The \codeword{ServerKeyExchange} message follows, containing additional information
needed by the client to compute the premaster secret. This message
is only sent in some key exchange methods, namely \codeword{DHE_DSS}, \codeword{DHE_RSA}
and \codeword{DH_anon}. For non-anonymous key exchanges, this is the message that authenticates the server to the client,
since the server sends a digital signature over the client and server randoms, as well as the server's key exchange parameters. Note that this is not the only place where the
server can authenticate itself to the client. For example, if \codeword{RSA} key
exchange is used, the server authentication is done indirectly when the client
sends the premaster secret encrypted with the public \gls{rsa} key provided in the
server certificate. Since only the server knows the corresponding private key, if
both of the sides generate the same keying material, then the server must be who
it claims to be. In \gls{tls} $1.3$ this message is non-existent and a similar
functionality is taken by the \codeword{key_exchange} extension.

The \codeword{ServerHelloDone} is sent to indicate the end of \codeword{ServerHello}
and associated messages. Upon the receipt of this message, the client should check
if the server provided a valid certificate. This message is not present in \gls{tls} 1.3.

With the \codeword{ClientKeyExchange} message the premaster secret is
set. This is done either by direct transmission of the secret generated by the client
and encrypted with the server's public \gls{rsa} key (thus, authenticating the server to the client)
or by the transmission of \gls{dh} parameters that will allow each side to generate
the same premaster secret independently. In \gls{tls} $1.3$ this message is
non-existent and a similar functionality is taken by the
\codeword{key_exchange} extension.

The \codeword{CertificateVerify} message is sent by the client to verify its
certificate. This message is only sent if client authentication is used and
if the client's certificate has signing capability (\textit{i.e.} all certificates except for the ones
containing fixed \gls{dh} parameters).

The \codeword{ChangeCipherSpec} is its own protocol, rather than a type of handshake
message. It is sent by both parties to notify the receiver that subsequent records
will be protected under the newly negotiated \codeword{cipher spec} and keys.
This message is not present in \gls{tls} $1.3$.

The \codeword{Finished} message is an essential part of the protocol. It is the first
message protected with the newly negotiated algorithms, keys and secrets. Only after
both parties have sent and verified the contents of this message they can
be sure that the Handshake has not been tampered with by a \gls{mitm} and begin to
receive and send application data. Essentially, this message contains a keyed hash
with the master secret over the hash of all the data from all of the
handshake messages not including any \codeword{HelloRequest} messages and up to, but
not including, this message. The other party must perform the same computation on its
side and make sure that the result is identical to the contents of the other party's
\codeword{Finished} message. If at some point a \gls{mitm} has tampered with the
handshake, there will be a mismatch between the computed and the received contents of the
\codeword{Finished} message.

At any time after a session has been negotiated, the server may send a \codeword{HelloRequest}
message, to which the client should respond with a \codeword{ClientHello}, thus
beginning the negotiation process anew.

At any point in the handshake, the Alert protocol may be used by any of the peers
to signal any problems or even abort the process through the use of an appropriate message type.

Besides the full handshake, \gls{tls} $1.2$ also defines an
abbreviated handshake mechanism, which can be used to either resume a previous session,
or duplicate one, instead of negotiating new security parameters. This
requires state to be maintained by both peers. The advantage of this mechanism is that the handshake is reduced
to \codeword{1 RTT}, instead of the usual \codeword{2 RTT}, as it is the case in the full handshake.

In order to perform an abbreviated handshake,
the client and the server must have established a session previously, by the
means of a full handshake. In its \codeword{ServerHello} phase, the server generates and sends a \codeword{session_id}, which will be associated with the newly negotiated session.

To resume a session, in its \codeword{ClientHello} phase the client includes the \codeword{session_id} of the session it wants to
resume. It is up to the server to decide if it
will resume that session. In the positive case, the server responds with a \codeword{ServerHello} containing
the same \codeword{session_id} value as the one sent by the client. In the negative
case, the \codeword{ServerHello} will contain a different \codeword{session_id} value, thus
triggering a new session negotiation process.

The keying material, such as the bulk
data symmetric encryption keys and the \gls{mac} keys are formed by hashing the new client
and server random values with the master secret. Therefore, provided that the master secret has not been compromised and that the secure
hash operations are, in fact, secure, the new connection will be secure and independent
from previous ones. The \gls{tls} $1.2$ spec, suggests and upper limit
of $24$ hours for \codeword{session ID} lifetimes, since an attacker which obtains the master secret
may be able to impersonate the compromised party until the corresponding \codeword{session ID} is retired.

\subsection{\gls{tls} Record Processing} \label{record}

A \gls{tls} record must go through some processing before it can be sent over the network.
This processing is done by the \textbf {TLS Record Protocol} and involves the following steps (\codeword{1-4} for \gls{tls} $1.2$ and \codeword{1, 3-4} for \gls{tls} $1.3$):

\begin{enumerate}
  \item \textbf{Fragmentation} - the \textbf{TLS Record Layer} takes arbitrary-length data and \textbf{fragments}
  it into manageable pieces: each one of the resulting fragments is called a \codeword{TLSPlaintext}.
  Client message boundaries are not preserved, which means that multiple messages
  of the same type may be placed into the same fragment or a single message may
  be fragmented across several records.
  \item  \textbf{Compression} (removed in \gls{tls} 1.3) - the \textbf{TLS Record Layer} compresses the
  \codeword{TLSPlaintext} structure according to the negotiated compression method,
  outputting \codeword{TLSCompressed}. Compression is optional. If the negotiated compression
  method is \codeword{null}, \codeword{TLSCompressed} is identical to \codeword{TLSPlaintext}.
  \item \textbf{Cryptographic Protection} - in \gls{tls} 1.2, either an
  \gls{aead} cipher or a separate encryption and \gls{mac} functions transform a
  \codeword{TLSCompressed} fragment into a \codeword{TLSCipherText} fragment. In the case
  of \gls{tls} 1.3, the \codeword{TLSPlaintext} fragment is transformed into a \codeword{TLSCipherText} by applying an \gls{aead} cipher, since all
  non-\gls{aead} ciphers have been removed.
  \item Append the \codeword{TLS Record Header} - encapsulate \codeword{TLSCipherText}
  in a \codeword{TLS Record}.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/tls-record-processing-3.png}
  \caption{\label{fig:tls-record-processing}TLS 1.2 Record Processing}
\end{figure}

The process described above, as well as the structure names are depicted in Figure \ref{fig:tls-record-processing}.
The compression step is not present in \gls{tls} 1.3. The structure names are exactly as the appear in the \gls{tls} specifications.

\subsection{\gls{tls} Keying Material} \label{keying}

In \gls{tls}, the confidentiality and integrity guarantees are achieved through the use
of \gls{sc}. Consequently, the communicating peers need to \textbf{share}
a \textbf{set of keys}. In \gls{tls} they are derived independently by the
client and the server, during the \gls{tls} Handshake Protocol.

The keys appear with different names in \gls{tls} $1.2$ and $1.3$ specs, but
they serve the same purpose. Additionally, more more keys can be found in
\gls{tls} $1.3$, for reasons that will be covered in Section \ref{tls-13}.
In \gls{tls} 1.2, the peers agree on the following set of keys:

\begin{itemize}
  \item \codeword{client write key} - used by the client to encrypt the data to be sent
  \item \codeword{client read_key} - used by the client to decrypt the incoming data from the server
  \item \codeword{server write key} - used by the server to encrypt the data to be sent
  \item \codeword{server read key} - used by the server to decrypt the incoming data from the server
  \item \codeword{client write IV} - used by the client for implicit nonce techniques with \gls{aead} ciphers
  \item \codeword{server_write_IV} - used by the server for implicit nonce techniques with \gls{aead} ciphers
  \item \codeword{client write MAC key} (\gls{tls} 1.2 only) - used by the client to authenticate the data to be sent
  \item \codeword{client write MAC key} (\gls{tls} 1.2 only) - used by the client to authenticate the data to be sent
\end{itemize}

When communicating with one another, the client uses one key to
encrypt the data that it sends to the server and another key, different from the first one, to decrypt the data
that it receives from the server, and vice-versa. This implies that the  following relationships must hold:
\codeword{client write key == server read key} and \codeword{server write key == client read key}.

\subsection{TLS 1.2 Keying Material Generation} \label{keying-material}

The generation of secret keys, used for various cryptographic operations involves the
following steps, in order:

\begin{enumerate}
  \item Generate the \textbf{premaster secret}.
  \item From the \textbf{premaster secret} generate the \textbf{master secret}.
  \item From the \textbf{master secret} generate the various secret keys, which
  will be used in the cryptographic operations.
\end{enumerate}

The derivation of the keying material needed for a connection is done using
the \gls{tls} \gls{prf}. It is defined as \codeword{PRF(secret, label, seed) = P_hash(secret, label + seed)}.
The \codeword{P_hash(secret, seed)} function is an auxiliary data expansion function
which uses a single cryptographic hash function to expand a \codeword{secret} and a \codeword{seed}
into an arbitrary quantity of output. Therefore, it can be used to generate
anywhere from $1$ to an infinite number of bits of output. \codeword{PRF(secret, label, seed)}
is used to generate as many bits of output as needed. When generating the
master secret, the \codeword{secret} input is the \codeword{premaster secret}.
When generating the key block, from which the final keys will be obtained,
the \codeword{secret} input is the \codeword{master secret}.

The cryptographic hash function used in \codeword{P_hash(secret, label, seed)} is
the hash function that is implicitly defined by the cipher suite in use. All of the cipher
suites defined in the \gls{tls} $1.2$ base spec use \codeword{SHA-256} and any new
cipher suites must explicitly specify a the same hash function or a stronger one.

\subsection{TLS 1.2 Key Exchange Methods} \label{key-exchange}

The way the peremaster secret is generated depends on the key exchange
method used. This is the only phase of the keying material generation
phase that is variable for a fixed cipher suite, since a cipher suite defines
the \gls{prf} function that will be employed. Neither the derivation of the
shared keys are impacted by the key exchange method.

There are many key exchange methods to choose from. Some of them
are defined in the base spec (\codeword{RFC5246}\cite{RFC5246}), while others
in separate \gls{rfc}s. For example, the \gls{ecc} based key exchange, specified
in \codeword{RFC4492} \cite{RFC4492}).

The base spec specifies four key exchange methods, one using \gls{rsa} and
three using \gls{dh}:

\begin{itemize}
  \item static \gls{rsa} (\codeword{RSA}; removed in \gls{tls} 1.3) - the client generates the premaster secret, encrypts it with the
  server's public key (which it obtained from the server's \codeword{X.509} certificate) and
  sends it to the server. The server then decrypts it using the corresponding private key and uses it as its premaster secret. \gls{pfs} is
  a property that preserves the confidentiality of past interactions even if the
  long-term secret is compromised. This key exchange method offers authenticity, but does not offer \gls{pfs}.
  \item anonymous \gls{dh} (\codeword{DH_annon}; removed in \gls{tls} 1.3) -
  each run of the protocol, uses
  different pubic \gls{dh} parameters, which are generated dynamically. This results
  in a different, \textbf{ephemeral} key being generated every time. Since the exchanged \gls{dh}
  parameters are \textbf{not authenticated}, the resulting key exchange
  vulnerable to \gls{mitm} attacks. \gls{tls} $1.2$ spec states that cipher suites
  using \codeword{DH_annon} \textbf{must not} be used, unless the application
  layer explicitly requests so. This key exchange offers \gls{pfs}, but does not offer
  authenticity.
  \item fixed/static \gls{dh} (\codeword{DH}; removed in \gls{tls} 1.3) - the server's/client's public \gls{dh} parameter
  is embedded in its certificate. This key exchange method offers authenticity,
  but does not offer \gls{pfs}.
  \item ephemeral \gls{dh} (\codeword{DHE}) - the \gls{dh} protocol is used, identically to \codeword{DH_annon}, but the public parameters
  are digitally signed in some way, usually using the sender's private
  \gls{rsa} (\codeword{DHE_RSA}) or \gls{dsa} (\codeword{DHE_DSS}) key. This key
  exchange offers both, authenticity and \gls{pfs}.
\end{itemize}

When either of the \gls{dh} variants is used, the value obtained from the exchange is used
as the premaster secret. Usually, only the server's
authenticity is desired, but client's can also be achieved if it supplies the
server with its certificate. Whenever the server is authenticated, it is secure
against \gls{mitm} attacks. Table \ref{kemsp} summarizes the security properties
offered by each key exchange method.

\begin{table}[]
\centering
\caption{Key exchange methods and security properties}
\label{kemsp}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Key Exch Meth} & \multicolumn{1}{l|}{Authentication} & PFS                    \\ \hline
RSA                          & X                                   &                        \\ \hline
DH\_anon                     & \multicolumn{1}{l|}{}               & \multicolumn{1}{c|}{X} \\ \hline
DH                           & X                                   &                        \\ \hline
DHE                          & X                                   & \multicolumn{1}{c|}{X} \\ \hline
\end{tabular}
\end{table}

In \gls{tls} $1.3$, static \gls{rsa} and \gls{dh} ciphersuites have been removed, meaning that all
public key exchange mechanisms now provide \gls{pfs}. Even though
anonymous \gls{dh} key exchange has been removed,
unauthenticated connections are still possible, by either using raw public keys\cite{RFC7250} or not verifying the certificate chain and any of its contents.

The use of \gls{ecc}-based key exchange (\gls{ecdh} and \gls{ecdhe}) and authentication (\gls{ecdsa})
algorithms with \gls{tls} is described in \codeword{RFC4492}\cite{RFC4492}. The document introduces five new
\gls{ecc}-based key exchange algorithms, all of which use \gls{ecc} to compute
the premaster secret, differing only in whether the negotiated
keys are ephemeral (\gls{ecdh}) or long-term (\gls{ecdhe}), as well as the mechanism (if any) used to
authenticate them. Three new \gls{ecdsa} \textbf{client authentication} mechanisms are also defined,
differing in the algorithms that the certificate must be signed with, as well
as the key exchange algorithms that they can be used with.
Those features are negotiated through \gls{tls} extensions.

\subsection{TLS Extensions} \label{extensions}

\gls{tls} extensions were originally defined in \codeword{RFC 4366}\cite{RFC4366}
and later merged into the \gls{tls} $1.2$ base spec. Each extension consists of an
extension type, which identifies the particular extension type, and extension data,
which contains information specific to a particular extension.

The extension mechanism can be used by \gls{tls} clients and servers; it is backwards
compatible, which means that the communication is possible between a \gls{tls} client that supports a particular extension and a server that does not support it,
and vice versa. A client may request the use of extensions by sending an extended \codeword{ClientHello}
message, which is just a normal \codeword{ClientHello} with an additional
block of data that contains a list of extensions. The backwards compatibility is achieved based on the \gls{tls}
requirement that the servers that are not extensions-aware must ignore the data
added to the \codeword{ClientHello}s that they do not understand (section \codeword{7.4.1.2} of \codeword{RFC 2246}\cite{RFC2246}). Consequently,
even servers running older \gls{tls} versions that do not support extensions, will not break.

The presence of extensions can be determined by checking if there are bytes
following the \codeword{compression_methods} field in the \codeword{ClientHello}.
If the server understands an extension, it sends back an extended \codeword{ServerHello},
instead of a regular one. An extended \codeword{ServerHello} is a regular
\codeword{ServerHello} with an additional block of data following the
\codeword{compression_method}, containing a list of extensions.

An extended \codeword{ServerHello} message can only be sent in a response to an
extended \codeword{ClientHello} message. This prevents the possibility that an extended
\codeword{ServerHello} message could cause a malfunction of older \gls{tls} clients that do not
support extensions. An extension type must not appear in the
extended \codeword{ServerHello}, unless the same extension type appeared in the
corresponding extended \codeword{CleintHello}, and if this happens, the client must abort the handshake.

\subsection{TLS 1.3} \label{tls-13}

Due to limited space, \gls{tls} $1.3$\cite{I-D.ietf-tls-tls13} will not be described in detail. 
The focus was on \gls{tls} $1.2$ instead, because at the time the work on the thesis started, 
\gls{tls} $1.3$ is still in draft mode and $1.2$ was the latest and the recommended to use version.
Despite the protocol name not suggesting it, \gls{tls} $1.3$ is
very different from \gls{tls} 1.2. It should have probably been called
\gls{tls} $2.0$ instead.

Numerous differences from \gls{tls} $1.3$ to $1.2$ have been mentioned throughout the document.
Various characteristics found in \gls{tls} $1.3$ make it more suitable for the context
of \gls{iot} than \gls{tls} $1.2$. Some of them were already mentioned previously, and in this section a additional ones will be outlined.

The first important difference is that the use of extensions is required in \gls{tls} $1.3$.
This can be explained by the fact that some of the functionality has been moved into extensions, in order to preserve
backwards-compatibility with the \codeword{ClientHello}s of the previous versions.
The way a server distinguishes if a client is requesting \gls{tls} $1.3$
is by checking the presence of the \codeword{supported_versions} extension in the
extended \codeword{ClientHello}.

In \gls{tls} $1.3$ more data is encrypted and the encryption begins earlier. For example,
at the server-side there is a notion of "encrypted extensions". The \codeword{EncryptedExtensions}
message, as the name suggests, contains a list of extensions that are encrypted
under a symmetric key. It contains any extensions that are not needed
for the establishment of the cryptographic context.

One of the main problems with using \gls{tls} in \gls{iot} is that while \gls{iot}
traffic needs to be quick and lightweight, \gls{tls} $1.2$ adds two additional
round trips (\codeword{2 RTT}) to the start of every session. \gls{tls} $1.3$ handshake has a lower latency,
and this is extremely important in the context of \gls{iot}.
The full \gls{tls} $1.3$ handshake is only \codeword{1 RTT}. \gls{tls} $1.3$ even allows
clients to send data on the first flight (known as \textbf{early client data}), when the clients
and servers share a \gls{psk} (either obtained externally or via a previous handshake).
This means that in \gls{tls} $1.3$ \codeword{0-RTT} data is possible, by
encrypting it with a key derived from a \gls{psk}. Session resumption
via identifiers and tickets has been obsoleted in \gls{tls} $1.3$, and both methods
have been replaced by a \gls{psk} mode. This \gls{psk} is established in a previous
connection after the handshake is completed and can be presented by the client
on the next visit.

Keying material generation is more complex in \gls{tls} $1.3$ than in
\gls{tls} $1.2$, since different
keys are used to encrypt data throughout the Handshake protocol. This can be
explained by the fact that in \gls{tls} $1.3$ the encryption begins earlier.
Other Handshake messages besides \codeword{Finished} are encrypted. As a result,
multiple encryption keys are generated and used to encrypt different data
throughout the handshake.

The way the keying material is derived is also different. The
\gls{prf} construction described above has been replaced.
In \gls{tls} 1.3, key derivation uses the
\gls{hkdf} function \cite{RFC5869} and its two components: \codeword{HKDF-Extract} and \codeword{HKDF-Expand}.
This new design allows easier analysis by cryptographers due to improved
key separation properties.

%
\subsection{\gls{dtls}} \label{dtls}

As already mentioned, \gls{dtls} is an adaption of \gls{tls} that runs on
top of an unreliable transport protocol, such as UDP. The design of \gls{dtls} is deliberately very similar to \gls{tls}, in fact, its specification is written
in terms of differences from \gls{tls}. This similarity allows to
both, minimize new security invention, and maximize the amount of code and infrastructure reuse. The changes are mostly done at the lower level and
don not affect the core of the protocol.
Even extensions defined before \gls{dtls} existed can be
used with it. The latest version of \gls{dtls} is $1.2$ and it is defined
in \codeword{RFC 6347}\cite{RFC6347}. There is a draft of \gls{dtls} $1.3$
\cite{I-D.ietf-tls-dtls13} that is currently under active development.

Since \gls{dtls} operates on top of an unreliable transport protocol, such as
UDP, it must explicitly deal with the absence of reliable and ordered assumptions
that are made by \gls{tls}. The main differences from \gls{dtls} $1.2$ to \gls{tls} $1.2$ are:

\begin{itemize}
  \item two new fields are added to the record layer: an explicit \codeword{2 byte} sequence
  number and a \codeword{6 byte} epoch. The \gls{dtls} \gls{mac} is the same as in \gls{tls},
  however, rather than using the implicit sequence number, the \codeword{8 byte} value
  formed by concatenation of the epoch number and the sequence number is used.

  \item stream ciphers must not be used with \gls{dtls}.

  \item a stateless cookie exchange mechanism has been added to the handshake protocol
  in order to prevent \gls{dos} attacks. To accomplish this, a new handshake
  message, the \codeword{HelloVerifyRequest} has been added. After
  the \codeword{ClientHello}, the server responds with a \codeword{HelloVerifyRequest}
  containing a cookie, which is returned back to the server in another
  \codeword{ClientHello} that follows it. After this, the handshake proceeds as in \gls{tls}. This is depicted in Figure \ref{fig:dtls-cookie}.   Although optional for the server, this mechanism highly recommended, and the
  client must be prepared to respond to it. \gls{dtls} $1.3$ follows the same idea, but does it differently, namely,
  the \codeword{HelloVerifyRequest} message has been removed, and the cookie is conveyed to the client via an extension in a \codeword{HelloRetryRequest} message.

  \item the handshake message format has been extended to deal with message reordering,
  fragmentation and loss by addition of three new fields: a message sequence field,
  a fragment offset field and a fragment length field.
\end{itemize}

\section{Related Work}

Lightweight cryptography is an important topic in the context of \gls{iot} security, due to the resource-limited nature of the devices. This section will begin with the description of the work done in this area.

Biryukov \textit{et al}\cite{Stateoft96:online} explore the topic of lightweight symmetric cryptography,
providing a summary of the lightweight symmetric
primitives from the academic community, the government agencies and even proprietary
algorithms which have been either reverse-engineered or leaked. All of those algorithms
are listed in the paper, alongside relevant metrics. The list will not be
included herein due to the lack of space. The authors also proposed
to split the field into two areas: ultra-lightweight and \gls{iot} cryptography.

The paper systematizes the knowledge in the area oe lightweight cryptography
in order to define "lightweightness" more precisely. The authors observed that the design
of lightweight cryptography algorithms varies greatly, the only unifying thread
between them being the low computing power of the devices that they are designed for.

The most frequently optimized metrics are the memory consumption, the implementation size
and the speed or the throughput of the primitive. The specifics depend on whether
the hardware or the software implementations of the primitives are considered.

If the primitive is implemented in hardware, the memory consumption and the implementation
size are lumped together into its gate area, which is measured in Gate Equivalents (GE),
a metric quantifying how physically large a circuit implementing the primitive is.
The throughout is measured in \textit{bytes/sec} and it corresponds to the amount of plaintext
processed per time unit. If a primitive is implemented in software (typically for
use in micro-controllers), the relevant metrics are the RAM consumption, the code
size and the throughput of the primitive, measured in \textit{bytes/CPU cycle}.

To accommodate the limitations of the constrained devices, most lightweight algorithms
are designed to use smaller internal states with smaller key sizes. After analysis,
the authors concluded that even though at least \codeword{128 bit} block and
key sizes were required from the AES candidates, most of the lightweight
block ciphers used only \codeword{64-bit} blocks, which leads to a smaller memory
footprint in both, software and hardware, while also making the algorithm better suited
for processing of smaller messages.

Even though algorithms can be optimized in implementation: whether it is
a software or a hardware, dedicated lightweight algorithms are still needed.
This comes down mainly to two factors: there are limitations to the the extent of
the optimizations that can be done and the hardware-accelerated encryption is
frequently vulnerable to various \gls{sca}s. An example of such an attack is the one done on the
Phillips light bulbs \cite{cryptoeprint:2016:1047}, where the authors were able to
recover a secret key used to authenticate updates.

It is more difficult to implement a lightweight hash function than a lightweight
block cipher, since standard hash functions need large amounts
of memory to store both: their internal states, for example, \codeword{1600 bits} in case of SHA-3,
and the block they are operating on, for example, \codeword{512 bits} in the case of SHA-2.
The required internal state is acceptable for a desktop computer, but not for a
constrained device. Taking this into consideration, the most common approach
taken by the designers is to use a sponge construction with a very small bitrate.
A sponge function is an algorithm with an internal state that takes as an input
a bit stream of any length and outputs a bit stream of any desired length. Sponge
functions are used to implement many cryptographic primitives, such as cryptographic
hashes. The bitrate decides how fast the plain text is processed and how fast the
final digest is produced. A smaller bitrate means that the output will take longer
to be produced, which means that a smaller capacity (the security level)
can be used, which minimizes the memory footprint at the cost of slower data
processing. A capacity of \codeword{128 bits} and a bitrate of \codeword{8 bits}
are common values for lightweight hash functions.

Another trend in the lightweight algorithms noticed by the authors is the
preference for \textit{ARX}-based and \textit{bitsliced-S-Box} based designs, as well as simple key schedules.

Finally, a separation of the "lightweight algorithm" definition into two distinct fields has been proposed:

\begin{itemize}
  \item \textbf{Ultra-Lightweight Crypto} - algorithms running on very cheap
  devices \textbf{not connected to the internet}, which are easily replaceable
  and have a limited life-time. Examples: \textit{RFID} tags, smart cards and remote car keys.
  \item \textbf{IoT Crypto} - algorithms running on a low-power device,
  \textbf{connected to a global network}, such as the internet. Examples: security cameras, smart light bulbs and smart watches.
\end{itemize}

Considering the two definitions above, this the work of this dissertation focuses on \textbf{IoT Crypto}
devices. A summary of differences between the both categories is summarized in
table \ref{ul-iot}.

\begin{table}[]
\centering
\caption{A summary of the differences between ultra-lightweight and IoT crypto}
\label{ul-iot}
\begin{tabular}{@{}lll@{}}
\toprule
                           & \textbf{Ultra-Lightweight}          & \textbf{IoT}                           \\ \midrule
\textbf{Block Size}        & 64 bits                             &  128 bits                             \\
\textbf{Security Level}    &  80 bits                           &  128 bits                             \\
\textbf{Relevant Attacks}  & low data/time complexity            & same as "regular" crypto               \\
\textbf{Intended Platform} & dedicated circuit (ASIC, RFID...)   & micro-controllers, low-end CPUs        \\
\textbf{SCA Resilience}    & important                           & important                              \\
\textbf{Functionality}     & one per device, e.g. authentication & encryption, authentication, hashing... \\
\textbf{Connection}        & temporary, only to a given hub      & permanent, to a global network         \\ \bottomrule
\end{tabular}
\end{table}

While there is a high demand for lightweight public key primitives, the required
resources for them are much higher than for symmetric ones. As a
paper by Katagi \textit{et al}\cite{b5b8db9716:online}
concluded, there are no promising primitives
that have enough lightweight and security properties, compared to the
conventional ones, such as RSA and \gls{ecc}. Further research on this topic, as part of the work on this dissertation, lead to the same conclusion.

Lightweight cryptography is an important topic this work and there are papers detailing
various algorithms. In order to provide a good overview of it while staying succinct, recent papers that provide a summary of the
area, rather than focusing on specific implementations, were chosen.
The remainder of this section will focus on the work done on the (D)\gls{tls} protocol in the context of \gls{iot}.

The "Scalable Security With Symmetric Keys"\cite{S3KScala62:online} paper proposes a key management architecture for resource-constrained devices,
which allows devices that have no previous, direct security relation to use
(D)\gls{tls} using one of two approaches: shared symmetric keys or raw public keys.
The resource-constrained device is a server that offers one or more resources,
such as temperature readings. The idea in both approaches is to introduce a third-party
\codeword{trust anchor (TA)} that both, the client and the server use to establish
trust relationships between them.

The first approach is similar to Kerberos\cite{RFC4120}, and it does not require any
changes to the original protocol. A client can request a \gls{psk} \codeword{Kc} from the \codeword{TA},
which will generate it and send it back to the client via a secure channel, alongside
a \codeword{psk_identity} which has the same meaning and use as in \codeword{RFC 4279}\cite{RFC4279}. When connecting to the server,
the client will send to the server the \codeword{psk_identity} that it received in a previous
handshake. Upon its receipt, the server will derive the \codeword{Kc}, using the
\codeword{P_hash()} function defined in \codeword{RFC 5246}\cite{RFC5246}.

The second approach consists in requesting an \gls{apk}
from the \codeword{TA}. The client includes his \gls{rpk} in its request, which is used for authorization. The TA
creates an authorization certificate, protects it with a \gls{mac} and sends it
to the client alongside the server's public key.
The client then sends this \gls{apk} (instead of the \gls{rpk})
when connecting to the server, which verifies it (to authorize the client)
and proceeds with the handshake in the \gls{rpk} mode, as defined in \codeword{RFC 4279} \cite{RFC4279}.
To achieve this, a new certificate structure is defined, alongside a new \codeword{certificate_type}.
The new certificate structure is just the \codeword{RFC7250} \cite{RFC7250} structure, with an
additional \gls{mac}.

The hash function used for key derivation is SHA256. The authors evaluated the
performance of their solution with and without SHA2 hardware acceleration and
concluded that while it had significant impact on key derivation, it had little
impact on the total handshake time (\codeword{711.11 ms} instead of \codeword{775.05 ms}), since most of the time was spent in sending
data over the network and other parts of the handshake, the longest one being
the \codeword{ChangeCipherSpec} message which required a processing time
of \codeword{17.79ms}.

6LoWPAN\cite{RFC4944} is a protocol that allows devices with limited processing
ability and power to transmit information wirelessly using the \codeword{IPv6}
protocol. The protocol defines IP Header Compression (IPHC) for the IP header, as well as,
Next Header Compression (NHC) for the IP extension headers and the UDP header in \codeword{RFC 6282}\cite{RFC6282}.
The compression relies on the shared context between the communicating peers.

The work proposed in \cite{6LoWPANC53:online} uses this same idea, but with the goal of compressing \gls{dtls} headers.
6LoWPAN does not provide ways to compress the UDP payload and layers above.
A proposed standard\cite{RFC7400} for generic header compression
for 6LoWPANs that can be used to compress the UDP payload, does exit, however. The authors propose
a way to compress \gls{dtls} headers and messages using this mechanism.

Their work defines how the \gls{dtls} Record header, the \gls{dtls} Handshake header,
the \codeword{ClientHello} and the \codeword{ServerHello} messages can be compressed, but notes that
the same compression techniques can be used to compress the remaining handshake
messages. They explore two cases for the header compression: compressing both,
the Record header and the Handshake header and compressing the Record header only,
which is useful after the handshake has completed and the fragment field of the
Record layer contains application data, instead of a handshake message.

\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{img/6lowpan-header.png} % first figure
  itself
\caption{\label{fig:6lowpan-header} IPv6 Next Header Compression}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.6\textwidth]{img/6lowpan-ghc-rhs.png} % second figur
  e itself
  \caption{\label{fig:6lowpan-ghc-rhs} LOWPAN\_NHC\_RHS structure}
\end{figure}


Each \gls{dtls} fragment is carried over as a UDP payload. In this case,
the UDP payload carries a header-like payload (the \gls{dtls} record header).
Figure \ref{fig:6lowpan-header} shows the way IPv6 next header compression is done.
The authors use the same value for the \codeword{LOWPAN_NHC Encoding} field (defined in \codeword{RFC 6282}\cite{RFC6282})
as in \codeword{RFC7400} and define the format of the \codeword{In-line Next Header Fields}
(also defined in \cite{RFC6282}), which is the compressed \gls{dtls} content. The \codeword{LOWPAN_IPHC Encoding}
and \codeword{In-Line IP Fields} fields are used in the IPv6 header compression
and are not in the scope of the paper.

All of the cases follow the same basic idea, for this reason only one of them will be exemplified:
the case where both, the Record and the Handshake headers are compressed.
In this case \codeword{LOWPAN_NHC Encoding} will contain the \codeword{LOWPAN_NHC_RHS}
structure (depicted in figure \ref{fig:6lowpan-ghc-rhs}), which is the compressed form of the Record and Handshake headers. The
parts that are not compressed will be contained in the \codeword{Payload} part.
The first four bits represent the ID field and in this case they are fixed to \codeword{1000},
that way, the decompressor knows what is being compressed (\textit{i.e} how to interpret
the structure that follows the ID bits). If the \codeword{F} field of the \codeword{LOWPAN_NHC_RHS} structure contains the
bit \codeword{0}, it means that the handshake message is not fragmented, so
the \codeword{fragment_offset} and \codeword{fragment_length} fields are
elided from the Handshake header (common case when a handshake message is not bigger than
the maximum header size), meaning that they are not going to be sent at
all (\textit{i.e.} they are not going to be present in the \codeword{Payload} part).
If the \codeword{F} bit has the value \codeword{1}, the \codeword{fragment_offset}
and \codeword{fragment_length} fields are carried inline (\textit{i.e.} they are
present in the \codeword{Payload} part). The remaining two fields define similar
behavior for other header fields (some of them assume that some default value is present, when a field is elided).
The \codeword{length} field in the Record and Handshake headers are always elided,
since they can be inferred from the lower layers.

The evaluation showed that the compression can save a significant number of bits:
the Record header, that is included in all messages can be compressed by \codeword{64 bits}
(\textit{i.e.} by $62\%$).

There is also a proposal for TCP header compression for 6LoWPAN\cite{I-D.aayadi-6lowpan-tcphc},
which if adopted, in many cases can compress the mandatory \codeword{20 bytes} TCP header
into \codeword{6 bytes}. This means that the same ideas can be applied to TCP and
\gls{tls} as well.

Later, in 2013, Raza \textit{et al.} proposed a security scheme called Lithe\cite{LitheLig40:online},
which is a lightweight security solution for \gls{coap} that uses the same \gls{dtls} header
compression technique as in \cite{6LoWPANC53:online} with the goal of implementing
it as a security support for \gls{coap}. \gls{coap}\cite{RFC7959} is a specialized
\textit{REST}ful Internet Application Protocol for constrained devices. it is designed to easily
translate to HTTP, in order to simplify its integration with the web,
while also meeting requirements such as multicast support and low overhead.
\gls{coap} is like "HTTP for constrained devices".
It can run on most devices that support UDP or a UDP-like protocol.
\gls{coap} mandates the use of \gls{dtls} as the underlying security protocol for
authenticated and confidential communication. There is also a \gls{coap} specification
running on top of TCP, which uses \gls{tls} as its underlying security protocol
currently being developed\cite{I-D.ietf-core-coap-tcp-tls}.

The authors evaluated their system in a simulated environment in \textit{Contiki OS}\cite{ContikiT75:online}, which is an open-source operating system for the \gls{iot}.
They obtained significant gains in terms of packet size (similar numbers to the
ones observed in \cite{6LoWPANC53:online}), energy consumption (on average $15\%$ less
energy is used to transmit and receive compressed packets), processing time
(the compression and decompression time of \gls{dtls} headers is almost negligible)
and network-wide response times (up to $50\%$ smaller RTT). The
gains in the mentioned measures are the largest when the compression avoids
fragmentation (in the paper, for payload size of \codeword{48 bytes}).

Angelo \textit{et al.} \cite{Security5:online} proposed to integrate the \gls{dtls} protocol
inside \gls{coap}, while also exploiting \gls{ecc} optimizations and minimizing
ROM occupancy. They implemented their solution in an off-the-shelf mote platform
and evaluated its performance. \gls{dtls} was designed to protect web application communication, as a result,
it has a big overhead in \gls{iot} scenarios. Besides that, it runs over UDP,
so additional mechanisms are needed to provide the reliability and ordering
guarantee. With this in mind, the authors wanted to design a version of \gls{dtls}
that both: minimizes the code size and the number of exchanged messages, resulting
in an optimized Handshake protocol.

In order to minimize the code size occupied by the \gls{dtls} implementation, they
decided to delegate the tasks of \textbf{reliability} and \textbf{fragmentation} to
\gls{coap}. This means that the code responsible for those functionalities,
can be removed altogether from the \gls{dtls} implementation, thus reducing ROM
occupancy. This part of their work was based on an informational RFC draft\cite{I-D.keoh-dtls-profile-iot}, in which the
authors profiled \gls{dtls} for \gls{coap}-based \gls{iot} applications and proposed
the use of a \textit{RESTful} \gls{dtls} handshake which relies on \gls{coap} block-wise
transfer to address the fragmentation issue.

To achieve this they  proposed the use of a \textit{RESTful} \gls{dtls} connection as a \gls{coap} resource,
which is created when a new secure session is requested.
The authors exploit the the \gls{coap}s capability to provide connection-oriented
communication offered by its message layer. In particular, each \codeword{Confirmable}
\gls{coap} message requires an \codeword{Acknowledgement} message (page 8 of \codeword{RFC 7252} \cite{RFC7252}),
which acknowledges that a specific \codeword{Confirmable} message has arrived, thus
providing reliable retransmission.

Instead of leaving the fragmentation function to \gls{dtls}, it was
delegated to the block-wise transfer feature of \gls{coap}\cite{RFC7959}, which was developed
to support transmission of large payloads. This approach has two advantages: first, the code in the \gls{dtls}
layer responsible for this function can be removed, thus reducing ROM occupancy,
and second, the fragmentation/reassembly process burdens the lower layers
with state that is better managed in the application layer.

The authors also optimized the implementation of basic operations on which
many security protocols, such as \gls{ecdh} and \gls{ecdsa} rely upon. The first
optimization had to do with modular arithmetic on large integers. A set of optimized
assembly routines based on \cite{Comparin25:Online} allow the improved use of
registers, reducing the number of memory operations needed to perform
tasks such as multiplications and square roots on devices with \codeword{8-bit} registers.

Scalar multiplication is often the most expensive operation in \gls{ec}-based
cryptography, therefore optimizing it is of high interest. The authors used a
technique called \textit{IBPV} described in \cite{LowcostS87:online}, which is based on pre-computation.
of a set of discrete log pairs. The mathematical details have been purposefully omitted,
since they are not relevant for this description. The \textit{IBPV} technique was used
to improve the performance of the \gls{ecdsa} signature and extended to the
\gls{ecdh} protocol. In order to reduce the time taken to perform an \gls{ecdsa}
signature verification, the \textit{Shamir Trick} was used, which allows
to perform the sum of two scalar multiplications (frequent operation in \gls{ec} cryptography)
faster than performing two independent scalar multiplications.

The results showed that the \gls{ecc} optimizations
outperform the scalar multiplication in the state of the art class 1 device platforms,
while also improving the the network lifetime by a factor of up to $6.5$ with
respect to a standard, non-optimized implementation. Leaving reliability and
fragmentation tasks to \gls{coap}, reduces the \gls{dtls} implementation code size
by approximately $23\%$.

\codeword{RFC 7925}\cite{RFC7925} describes a \gls{tls} and \gls{dtls} $1.2$
profile for \gls{iot} devices that offer communication security services
for \gls{iot} applications.
In this context, "profile" means available configuration options (ex: which
cipher suites to use) and protocol extensions that are best suited for \gls{iot} devices.
The document is rather lengthy, only its fundamental parts will be summarized. A number of relevant \gls{rfc}s will also be described.

\codeword{RFC 7925} explores both cases: constrained clients and constrained servers, specifying
a profile for each one and describing the main challenges faced in each scenario.
The profile specifications for constrained clients and servers are very similar.
Code reuse in order to minimize the implementation size is recommended. For example, an \gls{iot} device
using a network access solution based on \gls{tls}, such as EAP-TLS\cite{rfc5216}
can reuse most parts of the code for (D)\gls{dtls} at the application layer.

For the credential types the profile considers 3 cases:

\begin{itemize}
  \item \gls{psk} - authentication based on \gls{psk}s is described in
  \codeword{RFC 4249}\cite{RFC4279}. When using \gls{psk}s, the client indicates which
  key it wants to use by including a \gls{psk} identity in its \codeword{ClientKeyExchange} message.
  A server can have different \gls{psk} identities shared with different clients.
  An identity can have any size, up to a maximum of \codeword{128 bytes}.
  The profile recommends the use of shorter \gls{psk} identities and specifies
  \codeword{TLS_PSK_WITH_AES_128_CCM_8} as the only mandatory-to-implement
  cipher suite to be used with \gls{psk}s, just like \gls{coap} does. If a \gls{pfs} cipher suite is used, ephemeral
  \gls{dh} keys should not be reused over multiple protocol exchanges.

  \item \gls{rpk} - the use of \gls{rpk}s in (D)\gls{tls} is described in \codeword{RFC 7250}\cite{RFC7250}.
  With \gls{rpk}s, only a subset of the information that is found in typical certificates
  is used: namely the \codeword{SubjectPublicKeyInfo} structure, which contains
  the necessary parameters to describe the public key (the algorithm identifier
  and the public key itself). Other PKIX certificate\cite{RFCabc} parameters are
  omitted, making the resulted \gls{rpk} smaller in size, when compared to the
  original certificate and the code to process the keys simpler. In order for the
  peers to negotiate a \gls{rpk}, two new extensions have been defined:
  one for the client indicate which certificate types it can provide to the server, and one to indicate which certificate types it can process from the server. To further reduce the size of the implementation, the profile
  recommends the use of the \gls{tls} Cached Information extension\cite{RFC7924}, which
  enables \gls{tls} peers to exchange just the fingerprint (a shorter sequence of bytes
  used to identify a public key) of the public key. Identical to \gls{coap}, the only mandatory-to-implement
  cipher suite to be used with \gls{rpk}s is \codeword{TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8}.

  \item certificate - conventional certificates can also be used. The support
  for the Cached Information extension\cite{RFC7924} and the\\ \codeword{TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8}
  cipher suite is required. The profile restricts the use of named curves to
  the ones defined in \codeword{RFC 4492}\cite{RFC4492}. For certificate revocation, neither the
  \gls{ocsp}\cite{RFC6960}, nor the \gls{crl}\cite{RFCabc} mechanisms are used, instead this task is delegated to
  the software update functionality. The Cached Information extension does not
  provide any help with caching client certificates. For this reason, in cases
  where client-side certificates are used and the server is not constrained,
  the support for client certificate URLs is required. The client certificates URL
  extension\cite{RFC4366} allows the clients to point the server to a URL from
  which it can obtain its certificate, which allows constrained clients to
  save memory and amount of transmitted data. The Trusted CA Indication\cite{RFC6066}
  extension allows the clients to indicate which trust anchors they support, which is useful
  for constrained clients that due to memory limitation posses only a small number
  of \gls{ca} root keys, since it can avoid repeated handshake failures. If the clients interacts with
  dynamically discovered set of (D)\gls{tls} servers, the use of this extension is recommended,
  if that set is fixed, it is not.

\end{itemize}

The signature algorithms extension\cite{RFC5246} allows the client to indicate
to the server which signature/hash pairs it supports to be used with digital signatures.
The client must send this extension to indicate the use of \codeword{SHA-256},
otherwise the defaults defined in \cite{RFC5246} are used. This extension is not
applicable when \gls{psk}-based cipher suites are used.

The profile mandates that constrained clients must implement session
resumption to improve the performance of the handshake since this will lead to
less exchanged messages, lower computational overhead (since only symmetric cryptography
is used) and it requires less bandwidth. If server is constrained, but
the client is not, the client must implement the Session Resumption Without
Server-Side State mechanism\cite{RFC5077}, which is achieved through the
use of tickets. The server encapsulates the state into a ticket and forwards it to
the client, which can subsequently resume the session by sending back that ticket.
If both, the client and the server are constrained, both of them should implement
\codeword{RFC 5077}\cite{RFC5077}.

The use of compression is not recommended for two reasons. First, \codeword{RFC7525}\cite{RFC7525}
recommends disabling (D)\gls{tls} level compression, due to attacks such as \codeword{CRIME}\cite{Microsof72:online}.
\codeword{RFC7525} provides recommendations for improving the security of deployed services
that use \gls{tls} and \gls{dtls} and was published as a response to the various
attacks on (D)\gls{tls} that have emerged over the years. Second, for \gls{iot} applications,
the (D)\gls{tls} compression is not needed, since application-layer protocols are highly
optimized and compression at the (D)\gls{tls} layer increases the implementation's size and complexity.

\codeword{RFC6520}\cite{RFC6520} defines a heartbeat mechanism to test whether the peer
is still alive. The implementation of this extension is recommended for server
initiated messages. Note that since the messages sent to the client will most likely
get blocked by middleboxes, the initial connection setup is initiated by the
client and then kept alive by the server.

Random numbers play an essential role in the overall security of the protocol.
Many of the usual sources of entropy, such as the timing of keystrokes and the
mouse movements, will not be available on many \gls{iot} devices, which means that
either alternative ones need to be found or dedicated hardware must be added.
\gls{iot} devices using (D)\gls{tls} must be able to find entropy sources adequate for the generation of quality
random numbers, the guidelines and requirements for which can be found in \codeword{RFC4086}\cite{rfc4086}.

Implementations compliant with the profile must use \gls{aead} ciphers, therefore
encryption and \gls{mac} computation are no longer independent steps, which means
that neither encrypt-then-MAC\cite{RFC7366}, nor the truncated MAC\cite{RFC6066} extensions are applicable
to this specification and must not be used.

The \gls{sni} extension\cite{RFC6066} defines a mechanism for a client to
tell a (D)\gls{tls} server the name of the server that it is contacting. This is
crucial in case when multiple websites are hosted under the same IP address.
The implementation of this extension is required, unless the (D)\gls{tls}
client does not interact with a server in a hosting environment.

The maximum fragment length extension\cite{RFC6066} lowers the maximum fragment
length support of the record layer from $2^14$ to $2^9$. This extension allows
the client to indicate the server how much of the incoming data it is able to buffer,
allowing the client implementations to lower their RAM requirements, since it does not
not need to accept packets of large size, such as the \codeword{16K} packets required by
plain (D)\gls{tls}. For that reason, client implementations must support this
extension.

The Session Hash Extended Master Secret Extension\cite{RFC7627} defines an extension
that binds the master secret to the log of the full handshake, thus preventing
\gls{mitm} attacks, such as the triple handshake\cite{TripleHa89:online}. Even though the
cipher suites recommended by the profile are not vulnerable to this attack, the
implementation of this extension is advised. In order to prevent the renegotiation
attack\cite{RFC5746}, the profile requires the \gls{tls} renegotiation feature
to be disabled.

With regards to the key size recommendations, the authors recommend symmetric keys
of at least \codeword{112 bit}, which corresponds to a \codeword{233-bit} \gls{ecc}
key and to a \codeword{2048} \gls{dh} key. Those recommendations are made
conservatively under the assumption that \gls{iot} devices have a long expected
lifetime ($10+$ years) and that those key recommendations refer to the long-term
keys used for device authentication. Keys that are provisioned dynamically
and used for protection of transactional data, such as the ones used in
(D)\gls{tls} cipher suites, may be shorter, depending on the sensitivity of
transmitted data.

Even though \gls{tls} defines a single stream cipher: \textit{RC4}, its use is no longer
recommended due to its cryptographic weaknesses described in \codeword{RFC 7465}\cite{RFC7465}.

\codeword{RFC 7925}\cite{RFC7925} points out that designing a software
update mechanism into an \gls{iot} system is crucial to ensure that potential vulnerabilities
can be fixed and that the functionality can be enhanced. The software update mechanism
is important to change configuration information, such as trust anchors and
other secret-key related information. Although the profile refers to \codeword{LM2M}\cite{OpenMobi29:online}
as an example of protocol that comes with a suitable software update mechanism,
there has been new work done in this area since the release of this profile.
There is a document specifying an architecture for a firmware update
mechanism for \gls{iot} devices\cite{I-D.moran-suit-architecture} currently in Internet-Draft state.

\section{Methodology}

In (D)\gls{tls} the key the authentication algorithm, the encryption algorithm, the
data integrity algorithm, as well as the associated key sizes for each are all defined in a \textit{ciphersuite}.
A ciphersuite defines the security properties of a \acrshort{tlsd} connection. For this reason, the terms
\textit{ciphersuite} and \textit{configuration} will be used interchangeably.

A \gls{tlsd} connection consists of two main phases:
\begin{enumerate}
  \item The peers authenticate one to another, agree on the data encryption and integrity
  algorithms that they will use and establish the shared keys. This part is known as the handshake protocol.
 \item The peers exchange the data securely, using the algorithms and keys negotiated in
the previous step. This part is known as the record protocol.
\end{enumerate}

The relative cost of each phase depends on the chosen algorithms, as well as the amount of data
transferred. For this reason, it is important to evaluate the costs of both of them.

\acrshort{tlsd} has numerous possible configurations. Each one of those configurations is defined
in an \gls{rfc}. Each ciphersuite is assigned a unique identification number. \gls{iana} is responsible for
maintaining the full list of them. At the moment of this writing, there are over $300$ ciphersuites
defined for \gls{tlsd} \cite{IANA_ciphers_list:online}.

\textit{mbedTLS} implements a subset of those ciphersuites. As of version $2.7.0$, \textit{mbedTLS}
has a total of $161$ ciphersuites \cite{mbedTLS_ciphers_list:online}. Manual cost evaluation and
data analysis would greatly limit the scope of obtained results, as it would be very time consuming
and error-prone. For this reason, we developed tools that would automate the profiling and collection
of results.

In our work, we evaluated the \textit{mbedTLS's} implementation of the \gls{tls} protocol, thus obtained
metrics reflect the algorithm's implementations used within the library. The metric that we evaluated is the number
of CPU cycles executed. To be more precise, an estimate of that value. In the next section we will analyze the
evaluated metric in more detail, as well as describe its limitations.


\subsection{Evaluated Metrics and Limitations} \label{sec:eval-metrics-and-lims}

In order to estimate the number of executed cycles, we used \textit{valgrind}, more specifically
    its \textit{callgrind} tool. \textit{valgrind} runs the application on a synthetic CPU.
While running the code in that synthetic environment, it is able to insert instructions to perform
profiling and debugging.

In essence, \textit{valgrind} is a virtual machine, using \gls{jit}
compilation techniques, such as dynamic recompilation. Dynamic recompilation is a
feature where some part of the program is recompiled during execution.

The \textit{valgrind} tool consists of two parts, the \textit{valgrind core} and the \textit{tool
plugin}. The \textit{valgrind core} transforms the machine code into a simpler form called
\gls{ir}. The \gls{ir} code is then passed to the \textit{tool plugin}, which modifies the
\gls{ir} code as needed, typically by instrumenting it. This modified \gls{ir} code is then passed back to the
\textit{valgrind core}, which transforms it back into machine code. That recompiled machine code  will then run on the
host CPU (the \gls{jit} compilation step). This process is illustrated in Figure \ref{fig:how_valgrind_works}.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/how_valgrind_works.png}
  \centering \caption{\label{fig:how_valgrind_works} How Valgrind works}
\end{figure}

In our case, the \textit{tool plugin} is \textit{callgrind}. Among other metrics, \textit{callgrind}
collects the number of executed instructions, L1/L2 caches misses (the caches are simulated), and branch
prediction misses. The metrics collected by \textit{callgrind} can then be loaded into \textit{kcachegrind}
to visualize and analyze the performance results. One of such results is the estimate of the number of executed CPU cycles.
\textit{callgrind} and \textit{kcachegrind} are widely in conjunction for performance analysis and optimization
of programs. In order to count the number of executed CPU cycles, we derived a formula from
the one that is used by \textit{kcachegrind}.

The number of executed cycles
presented by \textit{kcachegrind} is an estimate, which might not correspond to the real value.
Although undocumented, we found the formula that estimates the number of executed CPU cycles in
\textit{kcachegrind}'s source code \cite{cachegrind_source:online}.
It uses the
following formula: $CEst = Ir + 10*Bm + 10*L1m + 20*Ge + 100*L2m + 100*LLm$, where

\begin{itemize}
  \item $CEst$ - estimated CPU cycles
  \item $Ir$ - instruction fetches
  \item $Bm$ -  mis-predicted branches (direct and indirect)
  \item $Ge$ - number of global bus events
  \item $L1m$ - total L1 cache misses (instruction fetch, data read and data write)
  \item $L2m$ - total L2 cache misses (instruction fetch, data read and data write)
  \item $LLm$ - total last-level cache misses (instruction fetch, data read and data write)
\end{itemize}

\textit{Callgrind} only simulates L1 and L2 caches, making $LLm=0$, therefore the actual formula
used by \textit{KCachegrind} (when used with \textit{Callgrind} output) is:
$CEst = Ir + 10*Bm + 10*L1m + 20*Ge + 100*L2m$.

$Ge$ is a useful metric when synchronization primitives are present, since it counts the number of
atomic instructions executed. For example, on the x86 and x86\_64 architectures, these are
instructions using the \textit{lock} prefix. In our evaluation, only single-threaded code was used, therefore
reason we did not measure $Ge$. This further simplified the formula used by \textit{kcachegrind} to
$CEst = Ir + 10*Bm + 10*L1m + 100*L2m$.

In order to estimate the number of CPU cycles, we developed tooling that parsed the metrics output by
\textit{callgrind} and input them into the \textit{kcachegrind}'s formula. All of the evaluations were performed in
our local machine, with its relevant characteristics shown in table \ref{table:local-machine}.

\begin{table}[]
\begin{tabular}{|l|l|}
\hline
Processor            & Intel(R) Core(TM) i7-4700HQ CPU @ 2.40GHz \\ \hline
L1 Instruction Cache & 32768 B, 64 B, 8-way associative          \\ \hline
L1 Data Cache        & 32768 B, 64 B, 8-way associative          \\ \hline
LL Cache             & 6291456 B, 64 B, 12-way associative       \\ \hline
\end{tabular}
\centering \caption{\label{table:local-machine} Local machine's characteristics}
\end{table}

We did not collect any measures on typical \gls{iot} processors. Despite that, the presented metrics are are still
relevant. If collected on an \gls{iot} processor, the metrics would all increase in a similar proportion, thus
the conclusions and analysis presented would still hold true. Moreover, it is possible to run \textit{callgrind}
on an \gls{iot} processor (either manually or using our automated tooling) and use those metrics for more accurate 
and device-specific CPU cycle estimation. In the next section we will describe which we tools developed in order 
to collect the metrics presented in this work. It is possible to use those tools in a local environment to 
automate metric collection.

\subsection{Developed Tools}

\textit{mbedTLS 2.7.0} includes many possible configurations for a \gls{tls} connection. It would be unfeasible to
perform a thorough and precise evaluation of its \gls{tls} implementation manually. For this reason, we developed a set
of tools to automate those tasks. In general, the developed tools served one for two purposes: metric collection and
collected metric analysis.

For the metric collection, we developed tools that would run a client-server connection with a set of ciphersuites.
Both, the client and server executables would be profiled with the \textit{callgrind} tool and the metrics would be saved.
It is also possible to specify how many bytes of data the client would send to the server and vice-versa.
This allows us to collect data encryption metrics.

For collected metric analysis, we developed tools that would use the collected \textit{callgrind} metrics to estimate the
number of CPU cycles for the specified \textit{mbedTLS} functions. \textit{mbedTLS} functions either implement \gls{tls} functionalities
(\textit{e.g.} the handshake protocol) or functionalities used by \gls{tls} (\textit{e.g.} \gls{rsa} signature creation).
After associating the function name(s) to each desired functionality, we could analyze their costs. The collected metrics can either
be analyzed individually (\textit{e.g.} compute the cost the handshake for a specific ciphersuite) or in conjunction (\textit{e.g.}
compute the average cost of the handshake for all of the ciphersuites that use a specific key exchange method).

All of the tools that we developed are open-source and their code can be found online \cite{iluxonch23:online},\cite{iluxonch44:online}, \cite{iluxonch73:online}.


\section{Results and Data Analysis}

The \gls{tlsd} protocol consists of two sub-protocols: the Handshake protocol and the Record protocol.
During the Handshake protocol, the peers authenticate one to another, agree on the data encryption and integrity
algorithms and establish the shared keys. During the Record protocol the peers exchange the data securely,
using the algorithms and keys negotiated during the Handshake protocol. Those algorithms support the security
services provided by \gls{tlsd}. For example, peer entity authentication is usually offered by algorithms, such
as \gls{rsa} or \gls{ecdsa}. The cost of the Handshake phase depends on the security services used. The cost
of the Record phase depends on the amount of data transmitted.

The core of the Record protocol is the use of a symmetric encryption algorithm (\textit{e.g} AES), used to
provide confidentiality and an \gls{hmac} algorithm, used to provide data integrity and data origin authentication.
The \gls{hmac} algorithm is not used if the symmetric encryption algorithm is an \gls{aead} cipher, which already
guarantees data integrity. Each encryption algorithm has a few possible varieties (\textit{e.g.} the CBC, GCM and CCM modes in AES)
and key sizes  (\textit{e.g.}, $128$ and $256$ bit for AES). The same is true for \gls{hmac} algorithms, which
have a well defined \gls{mac} function, key size and output length. The performance of symmetric encryption
algorithms and hash functions has been studied in detail by existing work \cite{nadeem2005performance} \cite{mathew2010performance}.
There is an approximately linear relation between the amount of data encrypted and the the cost.

The previous paragraph does not apply to the Handshake protocol. In this part, there is more variety in the
computational cost outcomes. There are a few reasons for that:

\begin{itemize}

  \item Asymmetric cryptography algorithms are used to provide security services of authentication
  and \gls{pfs}. For each algorithm, there are significantly more possible key sizes, when compared to
  symmetric encryption algorithms. Theoretically there is an infinite number of them, we will however, discuss
  practical limitations later in this text.

  \item In \gls{tlsd}, various algorithms, in various combinations can be used to provide authentication and \gls{pfs}.
  Two types of public key algorithms than can be used: \gls{ecc}-based and non-\gls{ecc}-based. It is also possible
  to have authentication without asymmetric cryptography. \gls{psk}-based ciphersuites allow peers to
  authenticate one to another by the means of a shared secret. This shared secret is then input to the \gls{prf}
  in the premaster key generation, without the use of public key cryptography.

  \item The use of asymmetric cryptography leads to asymmetric costs (\textit{i.e.} distinct costs) for the client and the server. The costs of asymmetric
  encryption algorithms vary greatly depending if the public or the private key is used. Also, while \gls{ecc}
  algorithms tend to have a smaller computational footprint, this is not always the case.
  Some operations (\textit{e.g} signature verification) is faster on the non-\gls{ecc} counterparts.
  It is important to consider those factors, when for example, only one of the peers is constrained, since the costs for the client and the server will be different.
  In the Record phase we do not have that problem, since the costs of \gls{hmac} and encryption/decryption in
  symmetrical encryption algorithms is approximately the same.

\end{itemize}

Another cryptographic operation that is done in the Handshake phase is keying material generation. This part, however,
does not have a major influence on the computational costs and is the same for both peers, since it is essentially
hashing operations.

It is clear that the Handshake protocol is significantly more complex, with more possible cost variations.
Furthermore, existing work neither evaluated the costs of individual security services of \gls{tls}, nor
their various combinations. For this reason, our work is concentrated around the Handshake protocol.

This section as structured as follows. Section \ref{sec:sls} describes the various security levels used for evaluation. 
Section \ref{sec:ss-overview}
presents an overview of the costs of authentication and \gls{pfs}. Section \ref{sec:psk-cost-analysis} discusses the costs of symmetric (or \gls{psk})
authentication. In Section \ref{sec:asym-algs-analysis} we analyze the costs of asymmetric authentication. We begin by analyzing the cost of \gls{rsa}'s
and \gls{ecdsa}'s  operations and then put everything together and present the authentication cost for each key exchange method (thus, for each ciphersuite).
Section \ref{sec:pfs-costs} does a similar analysis, but his time for the cost of \gls{pfs}. Here, once again, we begin by analyzing the costs of
\gls{ecdh} and \gls{dh}, after which we use that information to arrive at the \gls{pfs} cost for each key exchange method (thus, for each ciphersuite).
Section \ref{sec:tls-hs-cost} puts the information from the previous sections together and analyzes the cost of the \gls{tls} handshake as a whole.
We do both, present actual handshake cost values obtained by profiling its cost directly, and show how to use the information from the previous sections to 
arrive to those cost values without the need of executing and profiling the handshake costs directly. We decompose \gls{tls} costs into a single formula.
In Section \ref{sec:confid-costs} we discuss costs of confidentiality in \gls{tls} and compare the performance of all of the symmetric encryption algorithms
present in \textit{mbedTLS 2.7.0}. Finally, in section \ref{sec:ss-cost-conclusions} we present some conclusions.

\subsection{Security Levels} \label{sec:sls}

We performed evaluation under various security levels, which are presented in table \ref{table:tls-sec-lvls}.
The defined security levels are based on modern day security practices. The equivalence between symmetric and asymmetric
key sizes  is based on table \ref{table:ecc-key-sizes}. It shows approximate comparable key sizes for symmetric
and asymmetric key algorithms based on the best known algorithms for attacking them\cite{RFC4492}.

Unfortunately, mbedTLS does not have
the exact ECC curves for the  key sizes with the values specified in the the table. For this reason, for \gls{ecc}
we choose the closest larger value available.


\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
Security Level & Symmetric & ECC & DH/DSA/RSA \\ \hline
\textit{S1}    & 80        & 163 & 1024       \\ \hline
\textit{S2}    & 112       & 233 & 2048       \\ \hline
\textit{S3}    & 128       & 283 & 3072       \\ \hline
\textit{S4}    & 192       & 409 & 7680       \\ \hline
\textit{S5}    & 256       & 571 & 15360      \\ \hline
\end{tabular}
\centering \caption{\label{table:ecc-key-sizes} Comparable symmetric and asymmetric key sizes (in bits)}
\end{table}

\begin{table}[]
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                                                                       & \textbf{low} & \textbf{normal} & \textbf{high} & \textbf{very high} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Symmetric Key Size\\ (bits)\end{tabular}  & 128               & 128               & 192\addtocounter{footnote}{1}\addtocounter{footnotesintable}{1}\footnotemark[\thefootnote]             & 256            \\ \hline
  \begin{tabular}[c]{@{}l@{}}RSA/DH/DSA Key Size\\ (bits)\end{tabular} & 1024              & 2048              & 4092          & 8192           \\ \hline
  \begin{tabular}[c]{@{}l@{}}ECC Key Size\\ (bits)\end{tabular}        & 163 \addtocounter{footnote}{1}\addtocounter{footnotesintable}{1} \footnotemark[\thefootnote]               & 233 \addtocounter{footnote}{1}\addtocounter{footnotesintable}{1}\footnotemark[\thefootnote]               & 317\addtocounter{footnote}{1}\addtocounter{footnotesintable}{1}\footnotemark[\thefootnote]             & 420\addtocounter{footnote}{1}\addtocounter{footnotesintable}{1}\footnotemark[\thefootnote]              \\ \hline
  HMAC                                                                 & SHA-256           & SHA-256           & SHA-384       & SHA-512  \addtocounter{footnote}{1}\addtocounter{footnotesintable}{1}\footnotemark[\thefootnote]      \\ \hline
  \end{tabular}
  \centering \caption{\label{table:tls-sec-lvls} Security levels used in evaluation}
  \end{table}

\addtocounter{footnote}{-\thefootnotesintable}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The closest value available in mbedTLS 2.7.0 (rounded up) is $256$ bit}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The closest value available in mbedTLS 2.7.0 (rounded up) is $224$ bit}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The closest value available in mbedTLS 2.7.0 (rounded up)is $256$ bit}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The closest value available in mbedTLS 2.7.0 (rounded up) is $384$ bit}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The closest value available in mbedTLS 2.7.0 (rounded up) is $512$ bit}
\addtocounter{footnote}{1}\footnotetext[\thefootnote]{The strongest hash function available in mbedTLS is SHA-384}

We based the \textbf{normal} security level on the current most used \gls{tls} configuration on the internet \cite{QualysSS90:online}.
We could not find any typical values used in the sphere of \gls{iot}. In all of the security levels, a
certificate chain with two certificates is used: the \gls{ca}'s certificate
and the server's certificate. Only server-side authentication is used, since this is the most common scenario.
We decided to use the smallest possible certificate chain, consisting of two certificates. This is not the norm
on the internet, where the chain size is larger. However, adding more certificates to the chain would not provide additional
information, since the extra cost of additional certificates in the chain can be computed by adding the costs of
making/verifying additional signatures and parsing the certificates.

For all security levels, the server certificates are either
signed with a $2048$ bit \gls{rsa} with SHA-256 secure signing scheme \cite{RFC8017}, or with a $256$ bit \gls{ecdsa} with SHA-256 secure
signing scheme (\textit{secp256r1} curve) \cite{RFC6979},
depending on the ciphersuite.
The chosen signature algorithm and key size is based on the usual \gls{ca} practices. For example,
Google's root certificates with common names \textit{Google Internet Authority G2} and \textit{Google Internet Authority G3}
use this set up\cite{GoogleIn11:online}.

The server's certificates, however, contained public keys of different sizes, according to the certificate type.
For this reason, it is possible to deduce the cost of the \gls{ca}'s signature using a different algorithm with a
different key. For the \textbf{normal} security configuration, the certificates used by the server are as follows:

\begin{itemize}
  \item if \gls{rsa} authentication is used, the server's certificate will contain an $2048$ bit \gls{rsa} key;
  \item if \gls{ecdsa} authentication is used, the server's certificate will contain a $256$ bit \gls{ecc} key (\textit{secp256r1} curve);
  \item if \gls{dh} is used for \gls{pfs}, the negotiated key will be $2048$ bit long;
  \item if \gls{ecdh} is used fro \gls{pfs}, the negotiated key will be $256$ bit long and the \textit{secp256r1}
  curve will be used. The choice of this curve was based on the preferred curve order of Google Chrome $67$, the most
  used web browser in the world\cite{BrowserS4:online}.
\end{itemize}

Table \ref{table:sls-config-info} contains a the certificate configuration and key size information for all of the
security levels. The key sizes are presented in bits.

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
               & \textbf{low} & \textbf{normal} & \textbf{high} & \textbf{very high} \\ \hline
RSA Key Size   & 1024         & 2048            & 4092          & 8192               \\ \hline
ECDSA Key Size & 192          & 256             & 384           & 521                \\ \hline
DH Key Size    & 1024         & 2048            & 4092          & 8192               \\ \hline
ECDH Key Size  & 192          & 256             & 384           & 521                \\ \hline
ECC Curve      & secp192k1    & secp256r1       & secp384r1     & secp521r1          \\ \hline
\end{tabular}
\centering \caption{\label{table:sls-config-info} Security levels configuration}
\end{table}

\subsection{Evaluation of Security Services in TLS} \label{sec:ss-overview}

The \gls{tls} protocol offers various security services. The list of security services offered by a connection
depends on the used ciphersuite. Each ciphersuite consists of a set of algorithms, which have an implication
on the performance and cost. It is important to evaluate the cost of each security service to assist in making
security/performance trade-offs. A \textit{ciphersuite} can be thought of as \gls{tls} \textit{configuration},
thus, these terms be used interchangeably. In this section we will make a first, high level analysis of the
costs of security services in \gls{tls}.

As mentioned previously, the cost of the Handshake varies greatly, depending on the security level and algorithms used.
In this section an overview of the Handshake costs for the various configurations will be presented. For this
first evaluation, we will concentrate on the \textbf{medium} security level, which was defined in the text above.
\textit{mbedTLS 2.7.0} includes a total of $161$ ciphersuites, with $10$ unique key exchange methods, with $13$ unique
symmetric key encryption algorithms and $4$ unique hash functions. Some of the ciphersuites are disabled by default,
since they are considered weak. In the sphere of \gls{iot}, however, it might still make sense to use them in certain
scenarios, if their cost considerably lower. For this reason, we have enabled and evaluated all of the possible configurations.

Since the evaluated security level the server authenticates, but the client does not,
a separate analysis for both peers will be made. We will begin with an overview of the costs for the various \gls{tls}
configurations.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/hs_cost_cli.png}
  \centering \caption{\label{fig:hs-all-ciphers-cli} Client handshake cost for all of the $161$ ciphersuites}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/hs_cost_srv.png}
  \centering \caption{\label{fig:hs-all-ciphers-srv} Server handshake cost for all of the $161$ ciphersuites}
\end{figure}

Figures \ref{fig:hs-all-ciphers-cli} and \ref{fig:hs-all-ciphers-srv} depict a graph with the Handshake cost of each one
of the ciphersuites, for the client and the server, respectively. In both graphs, $y$ axis represents the number of
CPU cycles executed. The ciphersuites have been grouped by the key exchange method. Each bar within a key
exchange method group represents a different combination of a symmetric encryption function and a hash function.
The pink rectangles group the ciphersuites by the key exchange method. The numbers at the top of each rectangles indicate the average
number of CPU  cycles, in millions, used to perform the handshake for that key exchange method. The values are taken
from tables \ref{table:hs-all-ciphers-cli-aggr} and \ref{table:hs-all-ciphers-cli-aggr}.
An analysis of both figures shows that there is very little variation in costs within
each key exchange method group. This is due to the fact that most of the resources are spent in authenticating and
generating the keying material (either using \gls{pfs} or not).

From the analysis of Figures \ref{fig:hs-all-ciphers-cli} and \ref{fig:hs-all-ciphers-srv}, it becomes obvious
that some of the ciphersuites have  much lower handshake costs than the others. For the client, the \textit{PSK} based
ciphersuites are the least and \textit{ECHE-ECDSA} are the most expensive ones. For the server, the \textit{PSK} based
ciphersuites are the least and \textit{DHE-RSA} are the most expensive ones. To make the presented information clearer,
we took the average of the costs of all ciphersuites for each key exchange method. This information is presented in
table \ref{table:hs-all-ciphers-cli-aggr} for the client and in table \ref{table:hs-all-ciphers-srv-aggr} for the server.

\begin{table}[]
\begin{tabular}{cl|l|l|l|l|l|}
\cline{3-7}
\multicolumn{1}{l}{}                                                                        &                          & \multicolumn{2}{c|}{{\ul PFS}}            & \multicolumn{3}{c|}{{\ul No PFS}}                                                                     \\ \cline{2-7}
\multicolumn{1}{l|}{}                                                                       & \cellcolor[HTML]{C0C0C0} & \textbf{DHE}             & \textbf{ECDHE} & \textbf{ECDH}            & \textbf{RSA}                                    & \textbf{X}               \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Sym\\ Auth\end{tabular}}                    & \textbf{PSK}             & 135.443                  & 55.805         & \cellcolor[HTML]{C0C0C0} & 4.543                                           & 1.354                    \\ \hline
\multicolumn{1}{|c|}{}                                                                      & \textbf{RSA}             & 138.198                  & 58.608         & 57.412                   & \cellcolor[HTML]{C0C0C0}{\color[HTML]{333333} } & 4.559                    \\ \cline{2-7}
\multicolumn{1}{|c|}{\multirow{-2}{*}{\begin{tabular}[c]{@{}c@{}}Asym\\ Auth\end{tabular}}} & \textbf{ECDSA}           & \cellcolor[HTML]{C0C0C0} & 168.954        & 112.585                  & \cellcolor[HTML]{C0C0C0}                        & \cellcolor[HTML]{C0C0C0} \\ \hline
\end{tabular}
\centering
\centering \caption{\label{table:hs-all-ciphers-cli-aggr} Average handshake cost for the client in millions CPU cycles}
\end{table}


\begin{table}[]
\begin{tabular}{cl|l|l|l|l|l|}
\cline{3-7}
\multicolumn{1}{l}{}                                                                        &                          & \multicolumn{2}{c|}{{\ul PFS}}            & \multicolumn{3}{c|}{{\ul No PFS}}                                                                     \\ \cline{2-7}
\multicolumn{1}{l|}{}                                                                       & \cellcolor[HTML]{C0C0C0} & \textbf{DHE}             & \textbf{ECDHE} & \textbf{ECDH}            & \textbf{RSA}                                    & \textbf{X}               \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}c@{}}Sym\\ Auth\end{tabular}}                    & \textbf{PSK}             & 135.535                  & 56.021         & \cellcolor[HTML]{C0C0C0} & 77.369                                          & 1.383                    \\ \hline
\multicolumn{1}{|c|}{}                                                                      & \textbf{RSA}             & 212.255                  & 132.433        & 29.155                   & \cellcolor[HTML]{C0C0C0}{\color[HTML]{333333} } & 77.261                   \\ \cline{2-7}
\multicolumn{1}{|c|}{\multirow{-2}{*}{\begin{tabular}[c]{@{}c@{}}Asym\\ Auth\end{tabular}}} & \textbf{ECDSA}           & \cellcolor[HTML]{C0C0C0} & 86.097         & 29.094                   & \cellcolor[HTML]{C0C0C0}                        & \cellcolor[HTML]{C0C0C0} \\ \hline
\end{tabular}
\centering
\centering \caption{\label{table:hs-all-ciphers-srv-aggr} Average Handshake cost for the server in millions CPU cycles}
\end{table}

Each row and column intersection in the tables \ref{table:hs-all-ciphers-cli-aggr} and \ref{table:hs-all-ciphers-srv-aggr}
forms a ciphersuite. The rows separate the various authentication algorithms that can be used. The columns separate the
key exchange methods that offer \gls{pfs}, from the ones that don't. Each entry of the table presents the average
number of CPU cycles, in millions. In order to simplify this initial analysis, we are not presenting the standard deviation
values for the averages and are rounding up the results to millions, with $3$ decimal places. In Section \ref{sec:tls-hs-cost} we will present a
more detailed evaluation for all security levels.

\subsubsection{Client}

By analyzing table \ref{table:hs-all-ciphers-cli-aggr}  we can approximate
the costs of the security services of authentication and \gls{pfs} for the client. Even though those values are approximations,
they are very close actual numbers, since they dominate the costs of the Handshake. All of the costs presented here
are taken directly from table \ref{table:hs-all-ciphers-cli-aggr} and will be in millions CPU cycles,
rounded to $3$ decimal places.

If \gls{pfs} is used, the cost of the Handshake varies from $55.805$ to $135.443$
million CPU instructions for \gls{psk} based authentication, and from $58.608$ to $168.954$ million CPU cycles for
asymmetric authentication. If the security service of \gls{pfs} is foregone, the cost
of the Handshake varies from $1.354$ to $4.543$ for \gls{psk} based authentication,
and from $4.559$ to $112.585$ for asymmetric authentication.

If we analyze the values in the \textit{ECDHE} column in table \ref{table:hs-all-ciphers-cli-aggr}, thus fixing the
algorithm used to offer \gls{pfs} we can compare the costs of authentication for various algorithms on the client-side.
For example, we can see that \textit{RSA} authentication costs $2.803$  ($58.608 - 55.805$)
more than \gls{psk} authentication and \textit{ECDSA} authentication costs $110.346$ ($168.954 - 58.608$)
million CPU cycles more than
\textit{RSA} authentication. The total cost of using \gls{psk} for authentication can be estimated by looking at the
value in the \textit{PSK} row and \textit{X} column, thus fixing authentication to \textit{PSK} and not using any other
algorithm for key agreement: $1.354$. In fact, we can consider this value to be the overhead of \gls{tls} for the client,
since this is basically the cost of establishing the most basic \gls{tls} connection available in \textit{mbedTLS 2.7.0}.
In the same manner, the cost of using \textit{RSA} for authentication can
be approximated by taking the value located in row \textit{RSA} and column \textit{X}, thus fixing authentication
to \gls{rsa} and not using any other algorithm for key agreement: $4.559$. Even though we cannot estimate the cost
of using \textit{ECDSA} for authentication directly from the table, we have already seen that \textit{ECDSA} authentication
is $110.346$ more costly than \textit{RSA} authentication. Thus, the cost of using \textit{ECDSA} for authentication
is of $114.905 (4.559+110.346)$ million CPU cycles. When compared, authentication with \gls{rsa} is
$236.7\%$ more expensive than with \gls{psk} and authentication with \gls{ecdsa} is $2420.4\%$ more
expensive than with \gls{rsa}.

Similarly, we can compare the costs of using \gls{dh} vs \gls{ecdh} to provide \gls{pfs}, by
looking at the \gls{psk} (or \gls{rsa}) row, thus fixing the authentication algorithm. Using \textit{DHE} is
$76.638$ ($135.443 - 55.805$) million CPU cycles more $(+142.7\%)$ expensive than using \textit{ECDHE}.
The total cost of \gls{pfs}
using the \gls{ecdh} algorithm can be computed by fixing the \textit{PSK} row (or \gls{rsa} row)
and subtracting the value in the \textit{ECDHE} column from the value in the \textit{X} column. By doing this, we are
fixing the authentication algorithm to \gls{psk} and subtracting the cost of the Handshake when no \gls{pfs} is used,
from the cost of the handshake when \textit{ECDHE} is used to provide \gls{pfs}. Thus, the cost of using \textit{ECDHE}
to provide \gls{pfs} is of $54.451$ million CPU cycles ($55.805-1.354$). Since we already know that \textit{DHE} costs
$76.638$ million CPU cycles more than \textit{ECDHE}, we can compute the cost of using the \textit{DHE} to
provide \gls{pfs}: $131.089 (54.451+76.638)$ million CPU cycles.

\subsubsection{Server}

We will now perform the same analysis for the server by analyzing the table \ref{table:hs-all-ciphers-srv-aggr}. 
Once again, the presented costs will be approximations in
being millions CPU cycles rounded to $3$ decimal places.

If \gls{pfs} is used, the cost of the Handshake varies from $56.021$ to $135.535$
million CPU instructions for \gls{psk} based authentication, and from $86.097$ to $212.255$ million CPU cycles for
asymmetric authentication. If the security service of \gls{pfs} is foregone, the cost
of the Handshake varies from $1.383$  to $77.369$ for \gls{psk} based authentication,
and from $27.094$ to $77.261$ for asymmetric authentication.

If we analyze the values in the \textit{ECDHE} column in table \ref{table:hs-all-ciphers-srv-aggr}, thus fixing the
algorithm used to offer \gls{pfs} we can compare the costs of authentication for various algorithms on the server-side.
For example, we can see that \textit{RSA} authentication costs $76.412$ ($132.433-56.021$) more than \gls{psk}
authentication and \textit{ECDSA} authentication costs $46.336$ ($132.433-86.097$) million CPU cycles less
than \textit{RSA} authentication. The total cost of using \gls{psk} for authentication can be estimated
by looking at the
value in the \textit{PSK} row and \textit{X} column, thus fixing authentication to \textit{PSK} and not using any other
algorithm for key agreement: $1.383$. In fact, we can consider this value to be the overhead of \gls{tls} for the client,
since this is basically the cost of establishing the most basic \gls{tls} connection available in \textit{mbedTLS 2.7.0}.
In the same manner, the cost of using \textit{RSA} for authentication can
be approximated by taking the value located in row \textit{RSA} and column \textit{X}, thus fixing authentication
to \gls{rsa} and not using any other algorithm for key agreement: $77.261$. Even though we cannot estimate the cost
of using \textit{ECDSA} for authentication directly from the table, we have already seen that \textit{ECDSA} authentication
is $46.336$ less costly than \textit{RSA} authentication. Thus, the cost of using \textit{ECDSA} for authentication
is of $30.925 (77.261-46.336)$ million CPU cycles. When compared, authentication with \gls{ecdsa} is
$2136.1\%$ more expensive than with \gls{psk} and authentication with \gls{rsa} is $149.8\%$ more expensive
than with \gls{ecdsa}.

Similarly, we can compare the costs of using \gls{dh} vs \gls{ecdh} to provide \gls{pfs}, by
looking at the \gls{psk} (or \gls{rsa}) row, thus fixing the authentication algorithm. Using \textit{DHE} is
$79.514$ ($135.535 - 56.021$) million CPU cycles more expensive $(+141.9\%)$ than using \textit{ECDHE}. The total cost of \gls{pfs}
using the \gls{ecdh} algorithm can be computed by fixing the \textit{PSK} row (or \gls{rsa} row)
and subtracting the value in the \textit{ECDHE} column from the value in the \textit{X} column. By doing this, we are
fixing the authentication algorithm to \gls{psk} and subtracting the cost of the Handshake when no \gls{pfs} is used,
from the cost of the handshake when \textit{ECDHE} is used to provide \gls{pfs}. Thus, the cost of using \textit{ECDHE}
to provide \gls{pfs} is of $54.638 (56.021-1.383)$ million CPU cycles . Since we already know that \textit{DHE} costs
$79.514$ million CPU cycles more than \textit{ECDHE}, we can compute the cost of using the \textit{DHE} to
provide \gls{pfs}: $134.152 (54.638+79.514)$ million CPU cycles.

\subsubsection{Conclusion}

By analyzing at tables \ref{table:hs-all-ciphers-cli-aggr}
and \ref{table:hs-all-ciphers-srv-aggr} it is clear that some ciphersuites are more costly than others. This dissimilarity
can explained by the by fact that different ciphersuites use different security services and different algorithms to
offer those security services. By analyzing the Handshake costs we were able to approximate the costs of the security
services of authentication and \gls{pfs}, as well as of the algorithms used to offer them. This analysis made it clear that the
use or non-use of a security service can have a big impact on the cost of establishing a \gls{tls} connection.

Our analysis showed that \textit{PSK} based ciphersuites are the most efficient ones overall, for both, the client
and the server, thus their popularity in the \gls{iot} environment. Symmetric authentication is, by far,
the least costly one for both peers. For the client, \gls{rsa} is the second least costly authentication and \gls{ecdsa}
is the most costly one of them. For the server, this situation is reversed. The reasons for that will be explained in
Section \ref{sec:asym-algs-analysis}, when we analyze the Handshake costs in detail.

As for the \gls{pfs}, in both cases \textit{ECDHE} is about $1.5$ less costly than \textit{DHE}. This gives us a glimpse
into the benefits of elliptic curve cryptography. The costs of \gls{pfs} are identical for both peers. In the next
section we will analyze both of the security services in more detail.

The previous section gave an overview of the security services of authentication and \gls{pfs}. We deduced their
approximated cost by analyzing the costs of the Handshake with various ciphersuites. In the section that follows
we will do a more detailed analysis of those services and the underlying algorithms that support them.

\subsection{PSK Authentication Cost Analysis} \label{sec:psk-cost-analysis}

In \gls{tls} there are two ways of doing authentication: either by using a \gls{psk} or by using asymmetric cryptography.
If asymmetric cryptography is used, there are two choices for the algorithm: \gls{rsa} or \gls{ecdsa}.

In the previous section we compared the costs of different authentication methods by analyzing the total cost of the
Handshake with different ciphersuites. Now, we will analyze this security service in detail, including the
underlying algorithms. We will begin with an analysis of \gls{psk} authentication cost in this section and 
analyze asymmetric authentication costs in Section \ref{sec:asym-algs-analysis}.

In the previous section we approximated the cost of \gls{psk} authentication to be $1.119$ million CPU cycles
for the client and $1.217$ million CPU cycles for the server. In reality, this cost is very close to zero, since
both of the parties already have the authentication key. The approximated value is actually the cost of performing the
smallest and least costly handshake in \textit{mbedTLS}.
This value can be considered as the TLS overhead, since it is in essence, the cost of establishing the simplest possible \gls{tls} connection,
without using asymmetric authentication or \gls{pfs}. The majority of those costs are spent in the \gls{prf}, when generating the
shared keying material and in reading/writing the \textit{Finished} message. 

Table \ref{table:hs-key-gen-cost} shows the number of CPU cycles spent in the \gls{prf}
and in computing the \textit{Finished} message for all of the defined security levels.
This number is the average of the runs with each one the $161$ ciphersuites for both of the peers. Thus, it is
an average of $322$ samples. The standard deviation shown in parenthesis.
An analysis of the table shows that the cost of \gls{prf} is almost the same for all security levels. This can be explained by
the fact that both of the operations are essentially hashing operations and even if the input size varies
by a few hundred bytes, the total cost does not increase by a significant amount.
In \textit{mbedTLS 2.7.0} there are $26$ unique encryption/hash algorithms, $4$ of which use a \textit{NULL} encryption algorithm.
The \textit{Finished} message is the first encrypted message in \gls{tls}. Different encryption algorithms have different
performances. Due to this heterogeneity, the standard deviation is relatively higher for writing and parsing the \textit{Finished} message.

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                        & \textbf{low}   & \textbf{normal} & \textbf{high}  & \textbf{very high} \\ \hline
\textbf{PRF}            & 982957 (14830) & 986854 (19227)  & 992441 (29439) & 1009178 (50185)    \\ \hline
\textbf{Finished Write} & 158717 (22451) & 157912 (23253)  & 156648 (21950) & 158306 (22561)     \\ \hline
\textbf{Finished Parse} & 164680 (23952) & 164984 (26244)  & 163501 (24703) & 164897 (25322)     \\ \hline
\end{tabular}
\centering \caption{\label{table:hs-key-gen-cost} Cost of \gls{prf} and \textit{Finished} message}
\end{table}

The values in table \ref{table:hs-key-gen-cost} remain valid for all key exchange methods, and as we will see,
become very insignificant.

\subsection{Asymmetric Algorithms Authentication Cost Analysis} \label{sec:asym-algs-analysis}

If asymmetric cryptography is used for authentication, there are two
choices of algorithms: \gls{rsa} and \gls{ecdsa}. Each one of them has advantages and disadvantages, depending on the
scenario. We will analyze them now.

In \textit{mbedTLS 2.7.0}, there are $31$ ciphersuites that use \gls{rsa} to authenticate ephemeral \gls{dh}/\gls{ecdh} parameters
and $17$ ciphersuites that use \gls{ecdsa} to authenticate ephemeral \gls{dh}/\gls{ecdh} parameters. The metrics from those
ciphersuites can be used to analyze the cost of public and private key operations for both algorithms. Thus, all of the presented
costs for for \gls{rsa} are an average computed from $31$ runs, and for \gls{ecdsa} an average computed from $17$ runs, all from
different ciphersuites.

\gls{rsa} and \gls{ecdsa} have two basic operations: sign and verify. The first one uses the private key, while the
second one the public key. Figures \ref{fig:rsa-ecdsa-sign-ver-total-normal-sl} compares the performance of the algorithm's
operations for the \textbf{normal} security level (\textit{i.e.} $2048$ bit \gls{rsa} key and $256$ bit \gls{ecdsa} key).
The \textit{Total} cost is the sum of the \textit{Sign} and \textit{Verify} costs for the corresponding algorithm.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rsa_ecdsa_cost_normal_sl.png}
  \centering \caption{\label{fig:rsa-ecdsa-sign-ver-total-normal-sl} RSA and ECDSA operations cost for normal security level}
\end{figure}

By analyzing the graph, we can can observe two things:

\begin{itemize}
  \item \gls{rsa} is more efficient at performing public key operations, \textit{i.e.} verifying the signature
  \item \gls{ecdsa} is more efficient at performing private key operations, \textit{i.e.} making the signature
\end{itemize}

This holds true for other security levels too, as will be shown further down the text. Let us now analyze each one
of the algorithms and their costs in more detail.

\subsubsection{RSA Cost Analysis}

We have already seen the costs of \gls{rsa} for the \textbf{normal} security level and now we will analyze the
remaining ones. Table \ref{table:rsa-costs-all-sls} shows the number of CPU cycles used
when signing a message with size $20$, $32$ or $48$ bytes and verifying the resulting signature with \gls{rsa} and \gls{ecdsa}.
As already mentioned, the values are an average of $31$ runs for \gls{rsa} and $17$ for \gls{ecdsa}.
The numbers in parenthesis is the standard deviation. All of the values are rounded up to significant digits. The size of the signed message depends on the output size of the
hash function used with the ciphersuite. The cost differences between them are minimal, and for this reason we decided not to separate them.
Table \ref{table:rsa-costs-all-sls-total} presents the sum of the signing and verifying operation cost for \gls{rsa} and \gls{ecdsa}, which we call the \textit{Total} cost.
In out tests, both \gls{rsa} and \gls{ecdsa} signed certificates have signatures over a $32$ byte value (output of \textit{SHA-256}), so
the values in Table \ref{table:rsa-costs-all-sls} apply to those costs too.

Figure \ref{fig:rsa-costs-all-sls} depicts the costs of \gls{rsa} operations graphically. The data is presented in a logarithmic
scale. An analysis of the data shows that the exponential trendline is the one that best fits the cost increase for both, signature creation and
verification. This is a result of modular exponentiation being \gls{rsa}'s core operation. Moreover, for all security levels, the cost of
private key operations is significantly higher than
of the public key ones. The cost of the former also increases more, as the security level raises. For example, there is an increase
of $2145\%$ from the \textit{normal} to \textit{very high} security level for signature creation and of $1102\%$ for signature verification.

This results in a big difference between the cost of creating and verifying signatures, which becomes larger as the security level increases.
For example, at the \textit{normal} security level signature verification is approximately $74.6$ million CPU cycles more expensive,
while at the \textit{very high} security level, this value raises to over $1687$ million, \textit{i.e.} a $2161\%$ increase.

This increase more modest for public key operations. This information is shown Table \ref{table:rsa-pub-priv-cost-increasee} and graphically
in Figure \ref{fig:rsa-pub-priv-cost-increase}.
The percentages show the relative cost increase from the previous security level. For example, creating an \gls{rsa} signature costs
$268.4\%$ more at \textit{normal} than at \textit{low} security level. For all operations, the cost increase is exponential.
The consequences of the exponential cost increase are shown in table \ref{table:rsa-absolute-cost-increase}, which presents this relative increase
in terms of absolute values. The numbers are always going up, with the signature creation increase being significantly larger
than the signature verification one. An analysis Figure \ref{fig:rsa-pub-priv-cost-increase}
explains the difference between the costs of private and public key operations. As the security level increases, the relative cost
increase is larger for signing than for verifying. On average, the signing operation cost increase from one security level to another
is about $x1.5$ larger than the verifying one. This has a cumulative effect: the constantly larger value increases even more.
This is shown graphically in Figure \ref{fig:rsa-ecdsa-pub-priv-ratio}, which for \gls{rsa}, presents the ratio between the cost of private and
public key operations. As the security level increases, the value becomes larger. The fact that the signing operation dominates the total cost
can also be seen graphically in Figure \ref{fig:rsa-pub-priv-cost-increase}. The \textit{Total} cost increase line is very close to the
\textit{RSA Sign} cost increase line, in fact, they're almost identical. On average, the \textit{Total} cost increase is only $1.4\%$ smaller
than the signing operation cost increase.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                    & \textbf{RSA Sign}    & \textbf{RSA Verify} & \textbf{ECDSA Sign} & \textbf{ECDSA Verify} \\ \hline
  \textbf{low}       & 20559190 (117075)    & 398584 (198)        & 14497591 (49045)    & 26839273 (50816)      \\ \hline
  \textbf{normal}    & 75738802 (317047)    & 1117868 (748)       & 29512991 (95776)    & 56260702 (162365)     \\ \hline
  \textbf{high}      & 317087210 (716961)   & 3295296 (254)       & 49150396 (82047)     & 94077150 (130275)     \\ \hline
  \textbf{very high} & 1700652764 (2283718) & 13436728 (702)      & 59732056 (441815)   & 114744021 (843861)    \\ \hline
  \end{tabular}
  \centering \caption{\label{table:rsa-costs-all-sls} RSA and ECDSA signature creation and verification costs} \end{table}

\begin{table}[]
  \begin{tabular}{|l|l|l|}
  \hline
                     & \textbf{RSA Total} & \textbf{ECDSA Total} \\ \hline
  \textbf{low}       & 20957774           & 41336864             \\ \hline
  \textbf{normal}    & 76856670           & 85773693             \\ \hline
  \textbf{high}      & 320382506          & 143227546            \\ \hline
  \textbf{very high} & 1714089492         & 174476077            \\ \hline
  \end{tabular}
  \centering \caption{\label{table:rsa-costs-all-sls-total} RSA and ECDSA costs of signature creation + signature verification}
\end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
                   & \textbf{RSA Sign} & \textbf{RSA Verify} & \textbf{Total} \\ \hline
\textbf{low}       & -                 & -                   & -              \\ \hline
\textbf{normal}    & 268.4\%           & 180.5\%             & 266.7\%        \\ \hline
\textbf{high}      & 318.7\%           & 194.8\%             & 316.9\%        \\ \hline
\textbf{very high} & 436.3\%           & 307.8\%             & 435\%          \\ \hline
\end{tabular}
\centering \caption{\label{table:rsa-pub-priv-cost-increasee} Relative increase of RSA operation costs from previous security level}
\end{table}

\begin{table}[]
  \begin{tabular}{|l|l|l|l|}
  \hline
                     & \textbf{RSA Sign} & \textbf{RSA Verify} & \textbf{RSA Total} \\ \hline
  \textbf{low}       & -                 & -                   & -                  \\ \hline
  \textbf{normal}    & 55179612          & 719284              & 55898896           \\ \hline
  \textbf{high}      & 241348408         & 2177428             & 243525836          \\ \hline
  \textbf{very high} & 1383565554        & 10141432            & 1393706986         \\ \hline
  \end{tabular}
  \centering \caption{\label{table:rsa-absolute-cost-increase} Absolute increase of RSA operation costs from previous security level}
  \end{table}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rsa_cost_all_sls.png}
  \centering \caption{\label{fig:rsa-costs-all-sls} RSA operations costs for all security levels (logarithmic scale)}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rsa_relative_increase.png}
  \centering \caption{\label{fig:rsa-pub-priv-cost-increase} Relative increase of RSA operation costs}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rsa_ecdsa_operation_ratio.png}
  \centering \caption{\label{fig:rsa-ecdsa-pub-priv-ratio} Ratio between the most and the least costly operation for RSA and ECDSA}
\end{figure}

The reason for the discrepancy between the cost of public and private key operations has to do with an optimization
in the choice of the keys. \gls{rsa}'s public keys are deliberately chosen to have a small public exponent, such as $e=65537$. This is considered as a
sensible compromise, since it is famously known to be prime, large enough to avoid the attacks to which
small exponents make RSA vulnerable, and can be computed extremely quickly on binary computers \cite{boneh2002fast}\cite{muir2006seifert}.
A smaller exponent leads to less exponentiation operations, thus better performance. For this reason, public
key operations with \gls{rsa} are faster than private key ones.

\subsubsection{ECDSA Cost Analysis}

After analyzing the costs of \gls{rsa}, we will now perform a similar analysis for \gls{ecdsa}. Figure \ref{fig:ecdsa-costs-all-sls}
shows the costs of \gls{ecdsa} operations graphically. The values are taken from Table \ref{table:rsa-costs-all-sls}. Unlike in \gls{rsa},
in \gls{ecdsa} the private key operation is the least costly one. Figure \ref{fig:rsa-ecdsa-pub-priv-ratio} shows this ratio for both,
\gls{rsa} and \gls{ecdsa}. Besides the ratio being a lot smaller for \gls{ecdsa}, it varies very little. This means, that no matter
the security level, \gls{ecdsa} signature verification will always be about $2$ times more costly than signature creation.

As it is shown in figure \ref{fig:ecdsa-costs-all-sls}, a logarithmic trendline is the one that best fits the cost increase for both,
signature creation and verification.
Table \ref{table:ecdsa-relative-cost-increase} shows the relative cost increase of of \gls{ecdsa}'s operations. The percentages
show the relative cost increase from the previous security level. Figure \ref{fig:ecdsa-relative-cost-incerase} presents this information
graphically. There are two major differences from \gls{rsa}. First, the relative cost increase
of signature creation and verification is very similar. Consequently, the same is true for the total cost increase. This can be confirmed
graphically in Figure \ref{fig:ecdsa-relative-cost-incerase}, where all of the lines are
close one to another. As a result, even with the increase of security level, none of the operations will dominate as much as it happens
in \gls{rsa}. Second, as the security level increases, the cost increase from the previous security level becomes smaller. In fact, after the
\textbf{high} security level, the absolute cost increase starts decreasing as well. We can see this in table \ref{table:ecdsa-absolute-cost-increase}.
This is a consequence of the cost increase being logarithmic, which is a result of \gls{ecdsa}'s core mathematical operation being
multiplication of a scalar by a point on the curve. Although not presented here, this trend continues for higher security levels.
Those properties of \gls{ecdsa} makes the security level increase more manageable. It's not as costly to increase the security level for
\gls{ecdsa} as it for \gls{rsa}.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|}
    \hline
  & \textbf{ECDSA Sign} & \textbf{ECDSA Verify} & \textbf{Total} \\ \hline
  \textbf{low}       & -                 & -                   & -              \\ \hline
  \textbf{normal}    & 103.6\%           & 109.6\%             & 107.5\%        \\ \hline
  \textbf{high}      & 66.5\%            & 67.2\%              & 67\%           \\ \hline
  \textbf{very high} & 21.5\%            & 22\%                & 21.8\%         \\ \hline
  \end{tabular}
  \centering \caption{\label{table:ecdsa-relative-cost-increase} Relative increase of ECDSA operations cost from previous security level}
  \end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
                   & \textbf{ECDSA Sign} & \textbf{ECDSA Verify} & \textbf{ECDSA Total} \\ \hline
\textbf{low}       & -                   & -                     & -                    \\ \hline
\textbf{normal}    & 15015400            & 29421429              & 44436829             \\ \hline
\textbf{high}      & 19637405            & 37816448              & 57453853             \\ \hline
\textbf{very high} & 10581660            & 20666871              & 31248531             \\ \hline
\end{tabular}
\centering \caption{\label{table:ecdsa-absolute-cost-increase} Absolute increase of ECDSA operations cost from previous security level}
\end{table}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/ecdsa_realtive_cost_increase.png}
  \centering \caption{\label{fig:ecdsa-relative-cost-incerase} Relative increase of ECDSA operations cost}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/ecdsa_cost_all_sls.png}
  \centering \caption{\label{fig:ecdsa-costs-all-sls} ECDSA costs for all security levels}
\end{figure}

In the previous subsection we have described an optimization in the choice of keys for \gls{rsa}. There are no such optimizations
for \gls{ecdsa}. For this reason, it is expected that the cost of both operations will increase in similar proportion. The non-optimized
key (private for \gls{rsa}, private and public for \gls{ecdsa}) operation cost increase is a lot smaller for \gls{ecdsa}. This can be
explained by the fact that smaller keys are used in \gls{ecdsa}, as we have already seen in Table \ref{table:ecc-key-sizes},
and is a big advantage of \gls{ecc}.

\subsubsection{RSA vs ECDSA} \label{sec:rsa-vs-ecdsa}

After having analyzed the costs of \gls{rsa} and \gls{ecdsa}, we will now compare both and draw some conclusions. The answer to the
question of which one of algorithms is less costly will vary depending on the security level and the operation. Figure \ref{fig:ecdsa-rsa-costs-all}
shows the costs of both, \gls{rsa}'s and \gls{ecdsa}'s operations. The data is presented in logarithmic scale. Since for \gls{rsa} most
of the \textit{Total} cost comes from the signature creation operation, those two lines overlap in the graph.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rsa_ecdsa_costs_all.png}
  \centering \caption{\label{fig:ecdsa-rsa-costs-all} RSA and ECDSA cost comparison}
\end{figure}

By analyzing Figure \ref{fig:ecdsa-rsa-costs-all}, we can answer the question of \textit{Which algorithm is less costly?}:

\begin{itemize}
  \item \gls{rsa} is always less costly at signature verification
  \item \gls{ecdsa} is always less costly at signature creation
  \item \gls{rsa}'s cost increase is exponential
  \item \gls{ecdsa}'s cost increase is logarithmic
  \item Total cost of \gls{rsa} is smaller for the \textit{low} and \textit{normal} security levels
  \item Total cost of \gls{ecdsa} is smaller for the \textit{high} and \textit{very high} security levels
\end{itemize}

By analyzing tables \ref{table:rsa-pub-priv-cost-increasee}, \ref{table:rsa-absolute-cost-increase}, \ref{table:ecdsa-absolute-cost-increase} and
\ref{table:ecdsa-absolute-cost-increase} which show the relative and absolute cost increases for \gls{rsa} and \gls{ecdsa} operations, receptively,
we can see that as the security level increases, the cost of \gls{rsa} operations increases more and more, while after the \textbf{normal} security
level, the absolute cost increase of \gls{ecdsa} operations starts going down. Although not presented here, our tests show that this trend holds true
for higher security levels as well. This is a consequence of \gls{rsa} having an exponential cost increase, while \gls{ecdsa} a logarithmic one.
For this reason, it is safe to say that for security levels higher than the ones that we defined, \gls{ecdsa} would be the preferred choice.
\gls{rsa}' cost increases exponentially due to the mathematical operation at the algorithm's core: modular exponentiation. Similarly, the cost
increase in \gls{ecdsa} is logarithmic, due its \gls{ecc} properties: the base mathematical operation is multiplication of a scalar by a point on the
curve.

So which algorithm should be used for each security level? The answer to this question is not straightforward and will depend on the environment.
For example, if the scenario is a constrained client and a non-constrained server, \gls{rsa} would be the least costly choice. If, on the
other hand, the server is the constrained node, \gls{ecdsa} would be the least costly algorithm. If both of the nodes are
constrained, \gls{rsa} would be the least costly choice for the \textit{low} and \textit{normal} security levels, and \gls{ecdsa} for the remaining ones.
If the objective is  to have the costs for both peers as similar as possible, \gls{ecdsa} is the algorithm to use.

This information can also be used to make
certificate choices for mutual authentication scenarios, \textit{i.e.} when both, the client and the server authenticate one to another.
For example, if only one of the nodes is constrained, an \gls{rsa}-singed certificate from the non-constrained node and an \gls{ecdsa}-signed
certificate from the constrained node would minimize the costs for the constrained node. If both of the nodes are constrained, then the
choice of the least costly algorithm will be guided by the \textit{Total} cost: \gls{rsa} for the \textit{low} and \textit{normal}
security levels and \gls{ecdsa} for the \textit{high} and \textit{very high} security levels.

\subsubsection{The Cost Of Authentication in TLS} \label{sec:auth-cost-in-tls}

Having analyzed the costs of the algorithms that can be used for authentication, we will now describe the cost of this security service
for each one of the ciphersuites for the client and the server. Table \ref{table:tls-auth-cost-client} shows authentication costs for each
ciphersuite for the client. Table \ref{table:tls-auth-cost-server} shows the same information for the server. Each row specifies a key
exchange method and each column the security level.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                       & \textbf{low} & \textbf{normal} & \textbf{high} & \textbf{very high} \\ \hline
  \textbf{PSK}         & 0            & 0               & 0             & 0                  \\ \hline
  \textbf{RSA}         & 654077       & 2622235         & 5285561       & 16398134           \\ \hline
  \textbf{RSA-PSK}     & 654077       & 2622235         & 5285561       & 16398134           \\ \hline
  \textbf{ECDH-RSA}    & 1117868      & 1117868         & 1117868       & 1117868           \\ \hline
  \textbf{ECDH-ECDSA}  & 56260702     & 56260702        & 56260702      & 56260702          \\ \hline
  \textbf{ECDHE-PSK}   & 0            & 0               & 0             & 0                  \\ \hline
  \textbf{ECDHE-RSA}   & 1516452       & 2235736         & 4413164       & 14554596           \\ \hline
  \textbf{ECDHE-ECDSA} & 83099975     & 112521404       & 150337852     & 171004723          \\ \hline
  \textbf{DHE-PSK}     & 0            & 0               & 0             & 0                  \\ \hline
  \textbf{DHE-RSA}     & 1516452       & 2235736         & 4413164       & 14554596           \\ \hline
  \end{tabular}
  \centering \caption{\label{table:tls-auth-cost-client} Client authentication costs for all ciphersuites and security levels}
  \end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                     & \textbf{low} & \textbf{normal} & \textbf{high} & \textbf{very high} \\ \hline
\textbf{PSK}         & 0            & 0               & 0             & 0                  \\ \hline
\textbf{RSA}         & 20362831     & 75129504        & 314975365     & 1691976601         \\ \hline
\textbf{RSA-PSK}     & 20362831     & 75129504        & 314975365     & 1691976601         \\ \hline
\textbf{ECDH-RSA}    & 0            & 0               & 0             & 0                  \\ \hline
\textbf{ECDH-ECDSA}  & 0            & 0               & 0             & 0                  \\ \hline
\textbf{ECDHE-PSK}   & 0            & 0               & 0             & 0                  \\ \hline
\textbf{ECDHE-RSA}   & 20559190     & 75738802        & 317087210     & 1700652764         \\ \hline
\textbf{ECDHE-ECDSA} & 14497591     & 29512991        & 49150396      & 59732056           \\ \hline
\textbf{DHE-PSK}     & 0            & 0               & 0             & 0                  \\ \hline
\textbf{DHE-RSA}     & 20559190     & 75738802        & 317087210     & 1700652764         \\ \hline
\end{tabular}
  \centering \caption{\label{table:tls-auth-cost-server} Server authentication costs for all ciphersuites and security levels}
\end{table}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/tls-client-auth-cost.png}
  \centering \caption{\label{fig:tls-auth-cost-client} Client authentication cost (logarithmic scale)}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/tls-server-auth-cost.png}
  \centering \caption{\label{fig:tls-auth-cost-server} Server authentication cost (logarithmic scale)}
\end{figure}


Figures \ref{fig:tls-auth-cost-client} and \ref{fig:tls-auth-cost-server} are a graphical representation of tables \ref{table:tls-auth-cost-client} and \ref{table:tls-auth-cost-server},
respectively. In both of the figures, the data is presented in logarithmic scale. By looking at the graphs, it becomes evident that the some ciphersuites can be grouped together by authentication cost.
For the client, those groups are:

\begin{enumerate}
  \item \textit{PSK}, \textit{ECDHE-PSK}, \textit{DHE-PSK}
  \item \textit{ECDH-RSA}
  \item \textit{ECDHE-RSA}, \textit{DHE-RSA}
  \item \textit{RSA}, \textit{RSA-PSK}
  \item \textit{ECHD-ECDSA}
  \item \textit{ECHDE-ECDSA}
\end{enumerate}

For the server, those groups are:

\begin{enumerate}
  \item \textit{PSK}, \textit{ECDHE-PSK}, \textit{DHE-PSK}, \textit{ECDH-RSA}, \textit{ECDH-ECDSA}
  \item \textit{ECHDE-ECDSA}
  \item \textit{ECDHE-RSA}, \textit{DHE-RSA}
  \item \textit{RSA}, \textit{RSA-PSK}
\end{enumerate}

Inside every group, the authentication cost is the same, no matter the security level. Group numbers are ordered in ascending cost order, with Group $1$
being the least costly one, Group $2$ the second least costly one, and so on. All ciphersuites in the same group share a common set of operations that
are performed to provide authentication. We will discuss what those operations are further down in the text. Each ciphersuite uses either \gls{psk},
\gls{rsa} or \gls{ecdsa} for authentication. If only \gls{psk} is used for authentication, the cost of authentication is $0$. This is the case of Group
$1$ for the client and the server. At the end of the previous section we discussed which algorithm, \gls{rsa} or \gls{ecdsa} would be the least costly
choice. An analysis of authentication costs in \gls{tls} goes in hand with that discussion. By analyzing tables \ref{table:tls-auth-cost-client},\ref{table:tls-auth-cost-server}
and figures \ref{fig:tls-auth-cost-client}, \ref{fig:tls-auth-cost-client}, we can see that the cheapest choice for the client is \gls{rsa} and for the
server is \gls{ecdsa}. Similarly, for \gls{pfs} enabled ciphersuites, if the goal is to make the cost distribution as even as possible among the peers,
\gls{ecdsa} is the preferred choice. Having presented the costs of authentication for various key exchange methods and made a high-level analysis, we will now go into more detail and
justify each value.

In \gls{tls} it hard to talk about the cost of authentication without  talking about \gls{pfs}. If a \gls{pfs}-enabled
ciphersuite is used, an additional piece of information is authenticated in all non-\gls{psk} ciphersuites: the \textit{ServerKeyExchange} message.
This message contains a signature over the hash of the public \textit{(EC)DH parameters}. This has an implication of signature creation cost
for the server and a signature verification cost for the client. All non-\gls{psk} key exchange methods which begin with either
\textit{ECDHE} or \textit{DHE} incur in that extra cost.  We can use the values for the appropriate security level from table
\ref{table:rsa-costs-all-sls} to estimate them.

All \gls{rsa} server certificates are signed with a $2048$ bit \gls{rsa} key and all \gls{ecdsa} certificates
are signed with a $256$ bit \gls{ecdsa} key. This signature is made over an \textit{SHA-256} hash, which has an output size of $32$ bytes.
Thus, we can use the values from the \textit{normal} security level from table \ref{table:rsa-costs-all-sls} to compute the certificate signature
verification costs.

In \textit{RSA} and \textit{RSA-PSK} ciphersuites, the client uses the \textit{PKCS\#1 v2.1 RSAES-PKCS1\-V1\_5\-ENCRYPT}\cite{RFC3447}
encryption scheme to encrypt  the $48$ byte premaster secret. The server uses the corresponding \textit{PKCS\#1 v2.1 RSAES-PKCS1\-V1\_5\-DECRYPT}\cite{RFC3447}
decryption scheme to decrypt it. The cost of those operations are higher than of the regular sign/verify ones, due to extra steps performed.
Thus, to compute the authentication cost for those ciphersuites, in addition the the values from table \ref{table:rsa-costs-all-sls}, the ones
from table \ref{table:pkcs-cost} will also be used. In \textit{mbedTLS 2.7.0}, there are a total of
$38$ ciphersuites that use the \textit{PKCS\#1 v2.1} scheme as part of the authentication process: $23$
\textit{RSA} ciphersuites and $15$ \textit{RSA-PSK} ciphersuites. The values in table \ref{table:pkcs-cost} are an average
of $38$ runs: one for each ciphersuite. The numbers in parenthesis is the standard deviation.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                   & \textbf{low}      & \textbf{normal}   & \textbf{high}      & \textbf{very high}   \\ \hline
  \textbf{Encrypt} & 542291 (836)      & 1504367 (2012)    & 4167693 (2866)     & 15280266 (3748)      \\ \hline
  \textbf{Decrypt} & 20362831 (125590) & 75129504 (252921) & 314975365 (676291) & 1691976601 (2015526) \\ \hline
  \end{tabular}
  \centering \caption{\label{table:pkcs-cost} Cost of using \textit{PKCS\#1 V2.1 RSAES-PKCS1-v1\_5} encryption and decryption schemes with various security levels}
  \end{table}

The encryption operation uses the server's public key and the decryption operation the corresponding private key. Thus, as expected,
decryption is more costly than the encryption and both of the values increase, as the security level increases.

In order to authenticate, the client and the server perform different steps, depending on the ciphersuite. More specifically:

\begin{itemize}
  \item  in \textit{PSK}, \textit{DHE-PSK} and \textit{ECDHE-PSK} the authentication is done exclusively through the pre-shared secret, without any
  operations, thus the authentication cost is $0$.
  \item in \textit{RSA} and \textit{RSA-PSK} the client has to verify the server's \gls{rsa}-signed certificate and encrypt the premaster secret with
  the server's public \gls{rsa} key, while the server has to decrypt the premaster secret with the corresponding private key.
  \item in \textit{ECDH-RSA} ciphersuites, the client has to verify the server's \gls{rsa}-signed certificate and the server does not
  need to perform any operations.
  \item in \textit{ECDH-ECDSA} ciphersuites, the client has to verify the server's \gls{ecdsa}-signed certificate and the server does not
  need to perform any operations.
  \item in \textit{ECHDE-RSA} and \textit{DHE-RSA} ciphersuites the client has to verify the server's \gls{rsa}-signed certificate and
  the \textit{(EC)DH} \gls{rsa}-signed parameters, while the server has to perform an \gls{rsa} signature over the hash of \textit{(EC)DH} parameters.
  \item in \textit{ECHDE-ECDSA} ciphersuites the client has to verify the server's \gls{ecdsa}-signed certificate and
  the \textit{(EC)DH} \gls{ecdsa}-signed parameters, while the server has to perform an \gls{ecdsa} signature over the hash of \textit{(EC)DH} parameters.
\end{itemize}

In order to compute the authentication cost for each peer, we use the values from tables \ref{table:rsa-costs-all-sls} and \ref{table:pkcs-cost},
sum them up according to the steps described above. For example, when an \textit{ECDHE-ECDSA} ciphersuite is used at the \textit{normal} security level,
the client verify two \gls{ecdsa} signatures: one from the parsed server's certificate
and one from the \textit{ServerKeyExchange} message, while the server will only need to perform a signature over the \textit{ECDHE} parameters.
Thus, the authentication cost for the client will be $56260702+56260702=112521404$ and for the server $29512991$. Similarly, when an \textit{RSA} or
\textit{RSA-PSK} ciphersuite is used at the \textit{normal} security level, the client will verify the \gls{rsa} signature in the server's certificate
and perform a \textit{PKCS\#1 v2.1 RSAES-PKCS1\-V1\_5} encryption, while the server will only need to perform a
\textit{PKCS\#1 v2.1 RSAES-PKCS1\-V1\_5} decryption. Thus, the authentication cost for the client will be $1117868+1504367=2622235$ and for the server
$75129504$. The remaining entries in tables \ref{table:tls-auth-cost-client} and \ref{table:tls-auth-cost-server} are computed in a similar manner.
It is important to remember that independently of the security level, the server's certificates are always signed with either a $2048$ bit \gls{rsa}
keys or $256$ bit \gls{ecdsa} keys. Thus, for the certificate signature verification cost on the client side, the values from the \textit{normal}
security row of table \ref{table:rsa-costs-all-sls} are used.

Since in our evaluated scenario only the server authenticates, tables \ref{table:tls-auth-cost-client} and \ref{table:tls-auth-cost-server}
are non-identical. If mutual authentication was used (\textit{i.e.} with both, the client and server authenticating one to another), there would be
an additional cost of creating a signature for the client and of verifying the corresponding signature for the server.

\subsection{Perfect Forward Secrecy Cost Analysis} \label{sec:pfs-costs}

In \gls{tls} there are two ways of achieving \gls{pfs}: either by using the \gls{dh} algorithm or its \gls{ecc} counterpart \gls{ecdh}.
In section \ref{sec:ss-overview} we estimated the cost of \gls{pfs} and compared the two methods of achieving it by analyzing the total cost of the
Handshake with different ciphersuites. In this section, we will analyze this security service in detail, including the underlying algorithms.
In \gls{dh} and \gls{ecdh} the same basic operations are performed by each peer in sequence: generate a public/private keypair, exchange the public values
and derive the shared secret.

In \textit{mbedTLS 2.7.0} there are a total of $78$ ciphersuites that offer \gls{pfs}. $41$ of them use the \gls{ecdh} algorithm and $37$ of them use
the \gls{dh} algorithm. There are also $26$ ciphersuites that do not offer \gls{pfs}, but still use the \gls{ecdh} algorithm. The metrics obtained from the
Handshake analysis with those ciphersuites can be used to analyze the cost of the algorithms. Since the operations performed at the client and
the server side are identical, we do not need to present two separate analysis, like we did throughout Section \ref{sec:asym-algs-analysis}.
Moreover for \textit{ECDHE} and \textit{DHE}, we can analyze the metrics from both  of the peers in conjunction, thus doubling the sample size.
As for \textit{ECDH} ciphersuites, we can use the client-side results to analyze the cost of all \gls{ecdh} operations and the server-side results
to analyze the cost of the shared \gls{ecdh} secret generation operation.

Thus, all the presented cost values for \gls{ecdh}'s ephemeral key pair generation are an average computed from $108$ runs ($41$ from each
peer's \gls{pfs} ciphersuites and $26$ from client's non-\gls{pfs} ciphersuites),
and for the shared secret generation an average of $134$ runs ($41$ from each peer's \gls{pfs} ciphersuites and $26$ from each peer's non-\gls{pfs}
ciphersuites). For the \gls{dh} algorithm, the average for both operations is computed from $74$ runs ($37$ from each peer).

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/ecdh-dh-cost-normal-sl.png}
  \centering \caption{\label{fig:ecdh-dh-cost-normal-sl} ECDH and DH operations cost for normal security level}
\end{figure}

Figure \ref{fig:ecdh-dh-cost-normal-sl} compares the cost of \gls{ecdh}'s and \gls{dh}'s operations for the \textbf{normal} security level.
The total cost is the of the keypair and shared secret generation values for the corresponding algorithm. By analyzing the graph, we can can
observe two things:

\begin{itemize}
  \item \gls{ecdh} is less costly than \gls{dh}
  \item for both algorithms, the costs of generating the key pair and the shared secret are very similar.
\end{itemize}

The first observation is true starting from the \textbf{normal} security level and onwards.
The fact that for each algorithm the cost of generating the public/private keypair is very similar to the cost of generating secret is not a coincidence.
\gls{ecdh} and \gls{dh} use different mathematical operations, but for each one of them, those operations are the same for generating the keypair
and the shared secret. Thus, it is expected for the cost of both steps being almost identical. We will now analyze each one of the algorithms and
their costs in more detail.

\subsubsection{ECDH Cost Analysis}

In \gls{ecdh}, two basic operations are performed by each peer: first, a public/private \gls{ecc} keypair is generated, followed by generation of
the shared secret. The resulting shared secret will be a 2D $(x,y)$ coordinate on the curve. In \gls{tls} the $y$ value is discarded and $x$ is
used as the preshared secret. Computing the private key is cheap, since it is just a randomly generated number. The costly part is the computation of
the public key and the shared secret, since for both it involves multiplications of a scalar by a point on the elliptic curve.

We have already seen the costs of \gls{ecdh} for the \textbf{normal} security level and now we will analyze the remaining ones. Table
\ref{table:ecdh-dh-costs-all-sls} shows the number of CPU cycles for each \gls{ecdh} and \gls{dh} operation. As already mentioned, the values are
an average of $108$ runs for the \gls{ecdh}'s key generation, $134$ runs for \gls{ecdh}'s shared secret generation and of $34$ runs for both of \gls{dh}'s
operations. The numbers presented in parenthesis is the standard deviation. All of the values are rounded up to significant digits.
Table \ref{table:ecdh-dh-costs-total-all-sls} presents the sum of keypair and shared secret generation operations for for \gls{ecdh} and \gls{dh},
which we call the \textit{Total} cost. For both algorithms, the cost of generating the private key is less than $1\%$ of the keypair generation operation.
This is expected as the private key is just a randomly generated number, with size specific to the elliptic curves group.

Figure \ref{fig:ecdh-costs-all-sls} depicts the cost of \gls{ecdh} operations graphically. For all security levels the total cost is almost
evenly divided between the keypair and the shared secret generation. This is justified by the fact that the underlying mathematical operation is
the same when generating the public/private keys and the shared secret: multiplications of a scalar by a point on the curve. An analysis of the figure
also shows that a logarithmic trendline is the one that best fits the cost increase for all operations.

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                   & \textbf{ECDH Gen Keypair} & \textbf{ECDH Gen Secret} & \textbf{DH Gen Keypair} & \textbf{DH Gen Secret} \\ \hline
\textbf{low}       & 12942518 (33356)          & 12462677 (55222)         & 10455300 (31005)        & 10279378 (27044)       \\ \hline
\textbf{normal}    & 27483912 (94940)          & 26958612 (137745)        & 67136033 (108793)       & 66712994 (107669)      \\ \hline
\textbf{high}      & 45900358 (65731)          & 44331330 (100040)        & 474938146 (490496)      & 473634908 (493588)     \\ \hline
\textbf{very high} & 54449740 (487567)         & 53531554 (776984)        & 3592631108 (2792006)    & 3586324217 (2791154)   \\ \hline
\end{tabular}
\centering \caption{\label{table:ecdh-dh-costs-all-sls} ECDH and DH costs for all security levels}
\end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
                   & \textbf{ECDH Total} & \textbf{DH Total} \\ \hline
\textbf{low}       & 25405195            & 20734678          \\ \hline
\textbf{normal}    & 54442524            & 133849027         \\ \hline
\textbf{high}      & 90231688            & 948573054         \\ \hline
\textbf{very high} & 90231688            & 7178955325        \\ \hline
\end{tabular}
\centering \caption{\label{table:ecdh-dh-costs-total-all-sls} ECDH and DH costs of the sum of keypair and shared secret generation}
\end{table}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/ecdh_cost_all_sls.png}
  \centering \caption{\label{fig:ecdh-costs-all-sls} ECDH operations costs for all security levels}
\end{figure}

Table \ref{table:ecdh-relative-cost-increase} shows the relative cost increase of \gls{ecdh} operations from the previous security
level, with figure \ref{fig:ecdh-dh-relative-cost-increase} showing this same information graphically or the \textit{Total} cost increase (the blue line).
We're only presenting the the \textit{ECDH Total} column in the graph, because all are very similar, thus the $3$ lines would covering one another.
The total relative cost increase represents the average of the values of keypair and shared secret generation relative increase.
By analyzing the table and the corresponding graph, we can see  that as the security level increases, the cost increase  from the previous security
level becomes smaller. The effect decrease on the absolute cost increase can be seen in table \ref{table:ecdh-absolute-cost-increase}.
This table shows the absolute increase in the number of CPU cycles from
the previous security level. What can be clearly seen in this table is that after the \textbf{high} security level, the absolute cost increase starts
going down. Although not presented here, those trends continue for higher security levels.

There is a striking resemblance between the cost analysis of \gls{ecdh} and \gls{ecdsa}. In both algorithms, the cost increase is logarithmic.
In fact, the percentages for \gls{ecdsa} and \gls{ecdh} in tables \ref{table:ecdsa-relative-cost-increase}
and \ref{table:ecdh-relative-cost-increase}, we can see that the numbers are very similar. This similarity also reflects in the
trend that can be seen in tables \ref{table:ecdsa-absolute-cost-increase} and \ref{table:ecdh-absolute-cost-increase}, where in both cases, the
absolute cost increase starts going down from the \textbf{high} security level and onwards. Those similarities are not a coincidence, but rather
a result of the \gls{ecc} properties of both algorithms, more specifically, a consequence of the multiplication of a scalar by a point on
the curve being the core mathematical operation.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|}
  \hline
                     & \textbf{ECDH Gen Keypair} & \textbf{ECDH Gen Shared} & \textbf{ECDH Total}  \\ \hline
  \textbf{low}       & -                         & -                        & -                    \\ \hline
  \textbf{normal}    & 112.3\%                   & 116.3\%                  & 114.3\%              \\ \hline
  \textbf{high}      & 67\%                      & 64.4\%                   & 65.7\%               \\ \hline
  \textbf{very high} & 18.6\%                    & 20.8\%                   & 19.8\%               \\ \hline
  \end{tabular}
  \centering \caption{\label{table:ecdh-relative-cost-increase} Relative increase of ECDH operation costs from previous security level}
  \end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
                   & \textbf{ECDH Gen Keypair} & \textbf{ECDH Gen Shared} & \textbf{ECDH Total} \\ \hline
\textbf{low}       & -                         & -                        & -                   \\ \hline
\textbf{normal}    & 14541394                  & 14495935                 & 29037329            \\ \hline
\textbf{high}      & 18416446                  & 17372718                 & 35789164            \\ \hline
\textbf{very high} & 8549382                   & 9200224                  & 17749606            \\ \hline
\end{tabular}
\centering \caption{\label{table:ecdh-absolute-cost-increase} Absolute increase of ECDH operation costs from previous security level}
\end{table}

  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{img/ecdh_dh_relative_cost_increase.png}
    \centering \caption{\label{fig:ecdh-dh-relative-cost-increase} Relative increase of ECDH and DH operation costs}
  \end{figure}

\subsubsection{DH Cost Analysis}

Similarly to \gls{ecdh}, in \gls{dh} two basic operations are performed by each peer: first, a public/private \gls{dh} keypair is generated, followed
by generation of the shared secret, which in \gls{tls}, is used as the premaster secret. Computing the private key is cheap, since it is just a randomly
generated number. The costly part is the computation of the public key and the shared secret, since both of the operations involve modular exponentiations.

We will once again refer to table \ref{table:ecdh-dh-costs-all-sls} for the cost analysis, but this time focusing on \gls{dh}. Figure
\ref{fig:dh-costs-all-sls} shows the costs of \gls{dh}'s operations for all security levels graphically. Just like in \gls{ecdh}, the total cost
is almost evenly divided between the keypair and shared secret generation. This is a consequence of the fact that generating the public/private keys
and the shared secret involves the same type of mathematical operations, thus their costs are similar. An analysis of the figure
also shows that an exponential trendline is the one that best fits the cost increase for all operations.

  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{img/dh_costs_all_sls.png}
    \centering \caption{\label{fig:dh-costs-all-sls} DH operations costs for all security levels}
  \end{figure}

Table \ref{table:dh-relative-cost-increase} shows the relative cost increase of \gls{dh} operations from the previous security level. The \textit{Total}
cost increase is depicted graphically in figure \ref{fig:ecdh-dh-relative-cost-increase} (red line). We're only presenting the the \textit{DH Total} column
in the graph, because all are very similar, thus the $3$ lines would covering one another. The total relative cost increase represents the average of the
values of keypair and shared secret generation relative increase. An analyzing of table \ref{fig:ecdh-dh-relative-cost-increase} and figure
\ref{fig:ecdh-dh-relative-cost-increase} shows as the security level increases, the relative \gls{dh} cost increase becomes larger. In fact,
this cost increase is exponential. Although not presented here, this holds true for security levels higher than \textbf{very high}.
The effect of this exponential increase can be seen in table \ref{table:dh-absolute-cost-increase}, which shows the absolute cost increase from
the previous security level.

\begin{table}[]
  \begin{tabular}{|l|l|l|l|}
  \hline
                     & \textbf{DH Gen Keypair} & \textbf{DH Gen Shared}   & \textbf{DH Total}   \\ \hline
  \textbf{low}       & -                       & -                      & -                       \\ \hline
  \textbf{normal}    & 542.1\%                 & 549\%                  & 545.5\%                 \\ \hline
  \textbf{high}      & 607.4\%                 & 610\%                  & 608.7\%                 \\ \hline
  \textbf{very high} & 656.4\%                 & 657.2\%                & 656.8\%                 \\ \hline
  \end{tabular}
  \centering \caption{\label{table:dh-relative-cost-increase} Relative increase of DH operation costs from previous security level}
  \end{table}

  \begin{table}[]
    \begin{tabular}{|l|l|l|l|}
    \hline
                       & \textbf{DH Gen Keypair} & \textbf{DH Gen Shared} & \textbf{DH Total} \\ \hline
    \textbf{low}       & -                       & -                      & -                 \\ \hline
    \textbf{normal}    & 56680733                & 56433616               & 113114349         \\ \hline
    \textbf{high}      & 407802113               & 406921914              & 814724027         \\ \hline
    \textbf{very high} & 3117692962              & 3112689309             & 6230382271        \\ \hline
    \end{tabular}
    \centering \caption{\label{table:dh-absolute-cost-increase} Absolute increase of DH operation costs from previous security level}
    \end{table}

Similarly to \gls{rsa}, \gls{dh} has an exponential cost increase. This similarity is a consequence of both algorithms having the same mathematical
operation at their core: modular exponentiation.

\subsubsection{ECDH vs DH}

Having analyzed the costs of \gls{ecdh} and \gls{dh}, we will now compare them and draw some conclusions. Unlike in our comparison of
\gls{rsa} and \gls{ecdsa} in Section \ref{sec:rsa-vs-ecdsa}, the answer to which one of the algorithms is less costly, is straightforward.
In \gls{rsa} and \gls{ecdsa} the cost the signature creation and verification operations is different, so the choice of the least costly
option depended not only on the security level, but also on whether we were optimizing for the client or the server. In \gls{ecdh} and \gls{dh},
the total cost is almost evenly divided between the keypair and the shared secret generation. Thus, we can make our decision simply
by analyzing table \ref{table:ecdh-dh-costs-total-all-sls} and choosing which algorithm has the smallest value for each security level.
However, in order to simplify the analysis, we have plotted the table \ref{table:ecdh-dh-costs-all-sls} in figure \ref{fig:ecdh-dh-costs-all}, which
presents the data in logarithmic scale.

By looking at figure \ref{fig:ecdh-dh-costs-all} it is easy to see which algorithm has the smallest costs. If the \textbf{low} security level is being used,
\gls{dh} is the least costly choice, if the \textbf{normal} or any security level above is being used, \gls{ecdh} is. Moreover, we can clearly see that
for each algorithm, the costs of their operations is very similar, since we have overlapping lines. The logarithmic and exponential properties of
\gls{ecdh} and \gls{dh}, respectively, are also visible by shape of the lines. Since we are using logarithmic scale for the $y$ axis, the
exponential cost growth of \gls{dh} manifests in the shape of a line.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/ecdh_dh_costs_all.png}
  \centering \caption{\label{fig:ecdh-dh-costs-all} ECDH and DH cost comparison (logarithmic scale)}
\end{figure}

Although not presented here, the logarithmic and exponential growth trends for \gls{ecdsa} and \gls{dh}, respectively, hold true even for
security levels higher than \textbf{very high}. For security levels above \textbf{low}, from the costs and security perspective, there are no
reasons of choosing \gls{dh} over \gls{ecdh}, for either peer. For this reason, for security level above \textbf{low} it makes sense to abandon the
use of \gls{dh}, in favor of \gls{ecdh} completely. As a benefit of removing the \gls{dh} code implementation, the storage footprint will be smaller.

% NOTE: regarding the dhm code size look at mbedtls-2.7.0/library/CMakeFiles/mbedcrypto.dir/dhm.c.o

\subsubsection{The Cost Of PFS In TLS} \label{sec:pfs-cost-in-tls}

Having analyzed the costs of the algorithms that can be used for \gls{pfs}, in this section we will describe the cost of this security service
for each one of the ciphersuites for the client and the server. In order to avoid confusion in the text that follows, it is important to
distinguish the \textit{ECDH} ciphersuite from the \gls{ecdh} algorithm.

In \gls{tls} there are \textit{ECDH} and \textit{ECDHE} ciphersuites. Both use the \gls{ecdh} algorithm, but only \textit{ECDHE} ciphersuites
offer \gls{pfs}. The \textit{E} in \textit{ECDHE} stands for \textit{ephemeral}. While in \textit{ECHDE} ciphersuites, both the client and the server
generate ephemeral \gls{ecdh} parameters, in \textit{ECDH} ciphersuites at least one of the peer's parameters are \textbf{fixed}
within its certificate. In our scenario, only the server authenticates to the client, thus in \textit{ECDH} ciphersuites the server's
\gls{ecdh} parameters will be fixed within its certificate, while the client will have to generate new ones for each connection.
More specifically, in \textit{ECHDE} ciphersuites, with each  new Handshake, both the client and the server generate a new (\textit{i.e.} ephemeral)
public/private \gls{ecc} key pair that will be used with the \gls{ecdh} algorithm. On the other hand, in \textit{ECDH} ciphersuites, only the client
will generate a new public/private \gls{ecc} key pair, since the server's public key is fixed within its certificate. Thus in \textit{ECDH}
ciphersuites, if the server's long-term shared secret, \textit{i.e.t} its private \gls{ecc} key, is compromised the previous communication's secrets
can be computed (if the client's public \gls{ecdh} parameters that are sent in the clear are recorded), thus also compromising the confidentiality of
the past communications. The distinction between the \textit{DH} ciphersuite from \gls{dh} algorithm is equivalent. Although \textit{DH} (\textit{i.e}
non-ephemeral \gls{dh}) ciphersuites exist in \gls{tls}, they are not implemented in \textit{mbedTLS 2.7.0}.

Even though the \textit{ECDH} key exchange does not offer \gls{pfs}, it is still closely related to the \textit{ECDHE}, since both use
the \gls{ecdh} algorithm. The additional costs for \textit{ECDH} ciphersuites are significant, and in our evaluated scenario where only the server
authenticates to the client, there is no distinction in costs between \textit{ECDHE} and \textit{ECDH} ciphersuites for the client. Instead of
presenting multiple tables, we decided to show the cost of \gls{pfs} and the \textit{ECDH} key exchange in a single one.

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                                           & \textbf{low}                    & \textbf{normal}                 & \textbf{high}                   & \textbf{very high}               \\ \hline
\textbf{PSK}                               & 0                               & 0                               & 0                               & 0                                \\ \hline
\textbf{RSA-PSK}                           & 0                               & 0                               & 0                               & 0                                \\ \hline
\textbf{RSA}                               & 0                               & 0                               & 0                               & 0                                \\ \hline
\rowcolor[HTML]{9B9B9B}
{\color[HTML]{333333} \textbf{ECDH-RSA}}   & {\color[HTML]{333333} 25405195} & {\color[HTML]{333333} 54442524} & {\color[HTML]{333333} 90231688} & {\color[HTML]{333333} 107981294} \\ \hline
\rowcolor[HTML]{9B9B9B}
{\color[HTML]{333333} \textbf{ECDH-ECDSA}} & {\color[HTML]{333333} 25405195} & {\color[HTML]{333333} 54442524} & {\color[HTML]{333333} 90231688} & {\color[HTML]{333333} 107981294} \\ \hline
\textbf{ECDHE-PSK}                         & 25405195                        & 54442524                        & 90231688                        & 107981294                        \\ \hline
\textbf{ECDHE-RSA}                         & 25405195                        & 54442524                        & 90231688                        & 107981294                        \\ \hline
\textbf{ECDHE-ECDSA}                       & 25405195                        & 54442524                        & 90231688                        & 107981294                        \\ \hline
\textbf{DHE-PSK}                           & 20734678                        & 133849027                       & 948573054                        & 7178955325                        \\ \hline
\textbf{DHE-RSA}                           & 25405195                        & 133849027                        & 948573054                        & 7178955325                        \\ \hline
\end{tabular}
\centering \caption{\label{table:pfs-cost-client} \gls{pfs} and \textit{ECDH} key exchange for the client}
\end{table}

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                                           & \textbf{low}                    & \textbf{normal}                 & \textbf{high}                   & \textbf{very high}              \\ \hline
\textbf{PSK}                               & 0                               & 0                               & 0                               & 0                               \\ \hline
\textbf{RSA-PSK}                           & 0                               & 0                               & 0                               & 0                               \\ \hline
\textbf{RSA}                               & 0                               & 0                               & 0                               & 0                               \\ \hline
\rowcolor[HTML]{9B9B9B}
{\color[HTML]{333333} \textbf{ECDH-RSA}}   & {\color[HTML]{333333} 12462677} & {\color[HTML]{333333} 26958612} & {\color[HTML]{333333} 44331330} & {\color[HTML]{333333} 53531554} \\ \hline
\rowcolor[HTML]{9B9B9B}
{\color[HTML]{333333} \textbf{ECDH-ECDSA}} & {\color[HTML]{333333} 12462677} & {\color[HTML]{333333} 26958612} & {\color[HTML]{333333} 44331330} & {\color[HTML]{333333} 53531554} \\ \hline
\textbf{ECDHE-PSK}                         & 25405195                        & 54442524                        & 90231688                        & 107981294                       \\ \hline
\textbf{ECDHE-RSA}                         & 25405195                        & 54442524                        & 90231688                        & 107981294                       \\ \hline
\textbf{ECDHE-ECDSA}                       & 25405195                        & 54442524                        & 90231688                        & 107981294                       \\ \hline
\textbf{DHE-PSK}                           & 20734678                        & 133849027                       & 948573054                        & 7178955325                       \\ \hline
\textbf{DHE-RSA}                           & 20734678                        & 133849027                       & 948573054                        & 7178955325                       \\ \hline
\end{tabular}
\centering \caption{\label{table:pfs-cost-server} \gls{pfs} and \textit{ECDH} key exchange for the server}
\end{table}

Table \ref{table:pfs-cost-client} shows the cots of \gls{pfs} and the \gls{ecdh} key exchange for the client and table \ref{table:pfs-cost-server}
for the server. As a reminder, only \textit{ECDHE} and \textit{DHE} ciphersuites offer \gls{pfs}. \textit{ECDH-RSA} and \textit{ECDH-ECDSA}
ciphersuites (rows highlighted in gray), do not offer \gls{pfs} and the presented costs are the \textit{ECDH} key exchange overhead. Note, that the
highlighted rows, \textit{i.e.} the ones that refer to \textit{ECDH} key exchange and not \gls{pfs} cost, are the only ones whose cost differs for
the client and the server. For the server, the cost of \gls{ecdh} key exchange is the cost of generating the shared secret only.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/pfs_cost_all_sls.png}
  \centering \caption{\label{fig:pfs-cost-all-sls} \gls{pfs} and \textit{ECDH} key exchange costs (logarithmic scale)}
\end{figure}

Figure \ref{fig:pfs-cost-all-sls} shows the costs of tables \ref{table:pfs-cost-client} and \ref{table:pfs-cost-server} graphically, in logarithmic scale.
 Since the costs
of \textit{ECDH} ciphersuites are the only ones that differ between the client and the server, we decided to present both of the tables in a
single graph. Notice how the costs of \textit{ECDH-RSA} and \textit{ECDH-ECDSA} are distinguished explicitly for the client and the server.
In the figure, we can group the costs into $4$ groups, presented in increasing cost order:

\begin{enumerate}
  \item non-ECDH(E)/DH(E) ciphersuites, which have the total cost of $0$
  \item \textit{ECDH} server-side ciphersuites
  \item \textit{ECDH} client-side and \textit{ECDHE} ciphersuites
  \item \textit{DHE} ciphersuite
\end{enumerate}

In the evaluated scenario, only the server authenticates to the client. If mutual authentication was used (\textit{i.e.} with both, the client
and server authenticating one to another), the costs of \textit{ECDH} ciphersuites would become the same for the client and the server, with the client
having its cost reduced. In the mutual authentication scenario, the client, just like the server, would only have to generate the shared secret, since
its public key would be fixed in its certificate. Thus, the client's \gls{pfs} and \textit{ECDH} costs would be identical to the ones of the server,
presented in table \ref{table:pfs-cost-server}. Figure \ref{fig:pfs-cost-all-sls} would still look the same, except that the client's \textit{ECDH}
ciphersuite costs would become the same as the server's. Thus, the costs could still be separated into the $4$ groups mentioned above,
but now there would be no \textit{ECDH} client/server side separation:

\begin{enumerate}
  \item non-ECDH(E)/DH(E) ciphersuites, which have the total cost of $0$
  \item \textit{ECDH} ciphersuites
  \item \textit{ECDHE} ciphersuites
  \item \textit{DHE} ciphersuite
\end{enumerate}

\subsection{TLS Handshake Cost Analysis} \label{sec:tls-hs-cost}

Having analyzed the costs of the authentication and \gls{pfs} security services in \gls{tls}, we will now put everything together and
analyze the total cost of the handshake. We have already seen the Handshake cost for the \textbf{normal} security level in
Section \ref{sec:ss-overview}. In this section, we will present a more detailed analysis of this and the remaining security levels.

Tables \ref{table:client-hs-cost-all-sls} and \ref{table:server-hs-cost-all-sls} show the average handshake cost for each one of the
key exchange methods, for the client and server, respectively. The number in parenthesis in each table entry is the standard deviation.
The evaluated scenario is the most common one: only the server authenticates to the client.

In \textit{mbedTLS 2.7.0} there is a total of $161$ ciphersuites. Table \ref{table:mbedtls-num-ciphers} shows the number of
ciphersuites per each key exchange method available in \textit{mbedTLS 2.7.0}. For each key exchange method, the average was obtained
from a run with each one of the ciphersuites that use that key exchange.

\begin{table}[]
\begin{tabular}{ll}
\hline
\multicolumn{1}{|l|}{}                     & \multicolumn{1}{l|}{\textbf{Num Ciphersuites}} \\ \hline
\multicolumn{1}{|l|}{\textbf{PSK}}         & \multicolumn{1}{l|}{19}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{RSA-PSK}}     & \multicolumn{1}{l|}{15}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{RSA}}         & \multicolumn{1}{l|}{23}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{ECDH-RSA}}    & \multicolumn{1}{l|}{13}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{ECDH-ECDSA}}  & \multicolumn{1}{l|}{13}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{ECDHE-PSK}}   & \multicolumn{1}{l|}{11}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{ECDHE-RSA}}   & \multicolumn{1}{l|}{13}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{ECDHE-ECDSA}} & \multicolumn{1}{l|}{17}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{DHE-PSK}}     & \multicolumn{1}{l|}{19}                        \\ \hline
\multicolumn{1}{|l|}{\textbf{DHE-RSA}}     & \multicolumn{1}{l|}{18}                        \\ \hline
Total                                      & 161
\end{tabular}
\centering
\centering \caption{\label{table:mbedtls-num-ciphers} Number of ciphersuites per key exchange method in \textit{mbedTLS 2.7.0}}
\end{table}

\begin{table}[]
  \begin{tabular}{|l|l|l|l|l|}
  \hline
                       & \textbf{low}      & \textbf{normal}    & \textbf{high}      & \textbf{very high}   \\ \hline
  \textbf{PSK}         & 1354543 (51058)   & 1353865 (51289)    & 1355005 (51004)    & 1354829 (51043)      \\ \hline
  \textbf{RSA-PSK}     & 3536763 (71446)   & 4543238 (76038)    & 7293473 (84814)    & 18578392 (103341)    \\ \hline
  \textbf{RSA}         & 3556430 (59010)   & 4558935 (68078)    & 7309587 (71844)    & 18608492 (82623)     \\ \hline
  \textbf{ECDH-RSA}    & 28433250 (97731)  & 57412269 (122298)  & 93325335 (102107)  & 111532116 (623350)   \\ \hline
  \textbf{ECDH-ECDSA}  & 83731926 (78435)  & 112585306 (128327) & 148415289 (126285) & 166815336 (554471)   \\ \hline
  \textbf{ECDHE-PSK}   & 26819362 (68991)  & 55805138 (138561)  & 91713096 (142807)  & 109203285 (813689)   \\ \hline
  \textbf{ECDHE-RSA}   & 28862986 (105477) & 58608367 (214574)  & 96730901 (93708)   & 124773055 (696488)   \\ \hline
  \textbf{ECDHE-ECDSA} & 110524836 (93990) & 168954007 (267635) & 242501399 (149155) & 280626510 (1071418)  \\ \hline
  \textbf{DHE-PSK}     & 22189619 (55603)  & 135442518 (309751) & 950212732 (787892) & 7181764421 (5195398) \\ \hline
  \textbf{DHE-RSA}     & 24250886 (94421)  & 138197524 (198704) & 955840114 (861069) & 7196088947 (6405987) \\ \hline
  \end{tabular}
  \centering \caption{\label{table:client-hs-cost-all-sls} Handshake costs for the client}
  \end{table}

  \begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
                     & \textbf{low}      & \textbf{normal}    & \textbf{high}       & \textbf{very high}   \\ \hline
\textbf{PSK}         & 1380956 (50888)   & 1382849 (50737)    & 1381497 (50891)     & 1382002 (50903)      \\ \hline
\textbf{RSA-PSK}     & 22515609 (111975) & 77368868 (275574)  & 317389619 (662953)  & 1694178055 (2427763) \\ \hline
\textbf{RSA}         & 22456180 (121140) & 77260738 (239418)  & 317196961 (698637)  & 1694747500 (1705523) \\ \hline
\textbf{ECDH-RSA}    & 14534087 (49806)  & 29154666 (127699)  & 46480720 (107771)   & 55636527 (576001)    \\ \hline
\textbf{ECDH-ECDSA}  & 14521154 (58001)  & 29094320 (111114)  & 46390603 (132250)   & 55927921 (688074)    \\ \hline
\textbf{ECDHE-PSK}   & 26869449 (110405) & 56020895 (147825)  & 91773474 (94656)    & 109500050 (905013)   \\ \hline
\textbf{ECDHE-RSA}   & 48164890 (126885) & 132433386 (379327) & 409652623 (951326)  & 1810563620 (3011341) \\ \hline
\textbf{ECDHE-ECDSA} & 41984222 (82371)  & 86096716 (192885)  & 141506181 (147013)  & 169996896 (1051307)  \\ \hline
\textbf{DHE-PSK}     & 22308029 (76182)  & 135535409 (232955) & 950691653 (1289706) & 7181243788 (5402427) \\ \hline
\textbf{DHE-RSA}     & 43602094 (154553) & 212251542 (364611) & 1268235354 (857921) & 8883866054 (5993186) \\ \hline
\end{tabular}
  \centering \centering \caption{\label{table:server-hs-cost-all-sls} Handshake costs for the server}
\end{table}

Figures \ref{fig:client-hs-cost-all-sls} and \ref{fig:server-hs-cost-all-sls} are a graphical representation of tables \ref{table:client-hs-cost-all-sls}
and \ref{table:server-hs-cost-all-sls}, respectively. The $x$ axis specifies the security level. The $y$ axis presents the number
of CPU cycles used when performing the handshake with the specified key exchange method and security level.
The values are presented in logarithmic scale.  What can be clearly seen in those
graphs, is that even though there are $10$ unique key exchange methods, the costs of some of them overlap, because they are similar.
If two or more key exchange methods have similar costs, we say that they belong to the same \textit{cost group}. A \textit{cost group}
can also contain a single key exchange method, if its costs are significantly different from all others. In figures
\ref{fig:client-hs-cost-all-sls} and \ref{fig:server-hs-cost-all-sls} two or more key exchange methods belong to the same
cost group if their lines overlap throughout all security levels. By analyzing figure \ref{fig:client-hs-cost-all-sls} we can
find $6$ cost groups at the client-side:

\begin{enumerate}
  \item \textit{PSK}
  \item \textit{RSA}, \textit{RSA-PSK}
  \item \textit{ECDHE-PSK}, \textit{ECDHE-RSA}, \textit{ECDH-RSA}
  \item \textit{ECDH-ECDSA}
  \item \textit{ECHDE-ECDSA}
  \item \textit{DHE-PSK}, \textit{DHE-RSA}
\end{enumerate}

Similarly, by analyzing figure \ref{fig:server-hs-cost-all-sls}, we can find $8$ cost groups for the server side:

\begin{enumerate}
  \item \textit{PSK}
  \item \textit{ECDH-RSA}, \textit{ECDH-ECDSA}
  \item \textit{ECHDE-PSK}, \textit{ECDHE-ECDSA}
  \item \textit{RSA}, \textit{RSA-PSK}
  \item \textit{ECDHE-RSA}
  \item \textit{DHE-PSK}
  \item \textit{DHE-RSA}
\end{enumerate}

The groups are presented in ascending cost order. For both, the client and the server, the \textit{PSK} key exchange is, by far,
the cheapest option. The most expensive key exchange method depends on the peer and the security level. If we had to choose one
option for the title of the most expensive one, \textit{DHE-RSA} would be the answer, since this is true after the
\textbf{normal} security level for the client and after \textbf{low} security level for the server. \textit{DHE-PSK} is not
far away from that, specially for the client. Once again we see the advantage of \gls{ecc}, with the cost increase of
key exchanges that use \textit{ECDH(E)} and/or \textit{ECDSA} being much slower than of the ones that use \textit{DHE} and \textit{RSA}
instead. This is a manifestation of logarithmic (for \gls{ecc}) vs exponential (for non-\gls{ecc}) cost increase.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/client_hs_costs_all_sls.png}
  \centering \caption{\label{fig:client-hs-cost-all-sls} Client handshake costs for all security levels}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/server_hs_costs_all_sls.png}
  \centering \caption{\label{fig:server-hs-cost-all-sls} Server handshake costs for all security levels}
\end{figure}

\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
                     & \textbf{Asymmetric Auth} & \textbf{PFS} \\ \hline
\textbf{PSK}         & No                       & No           \\ \hline
\textbf{RSA-PSK}     & Yes                      & No           \\ \hline
\textbf{RSA}         & Yes                      & No           \\ \hline
\textbf{ECDH-RSA}    & Yes                      & No           \\ \hline
\textbf{ECDH-ECDSA}  & Yes                      & No           \\ \hline
\textbf{ECDHE-PSK}   & No                       & Yes          \\ \hline
\textbf{ECDHE-RSA}   & Yes                      & Yes          \\ \hline
\textbf{ECDHE-ECDSA} & Yes                      & Yes          \\ \hline
\textbf{DHE-PSK}     & No                       & Yes          \\ \hline
\textbf{DHE-RSA}     & Yes                      & Yes          \\ \hline
\end{tabular}
\centering \caption{\label{table:key-exch-sec-ser} Security services offered by each key exchange}
\end{table}


Due to the constrained nature of \gls{iot} devices, it is important to choose the least costly option for the desired secure
connection properties.
The cost differences between key exchange methods exist for two reasons. First, different key exchange methods offer different
security services. Table \ref{table:key-exch-sec-ser} shows the security services offered by each key exchange method. Second, as
discussed and analyzed throughout Section \ref{sec:auth-cost-in-tls}, different algorithms can be used to offer the same
security service, thus leading to different costs. In order to make a choice of the cheapest key
exchange method, we need to answer $4$ questions:

\begin{enumerate}
  \item what is the desired security level?
  \item do we want to optimize for the client, the server or both?
  \item is asymmetric authentication necessary?
  \item is \gls{pfs} necessary?
\end{enumerate}

Figures \ref{fig:dt-low-sl}, \ref{fig:dt-normal-sl}, \ref{fig:dt-high-sl}, \ref{fig:dt-veryhigh-sl} are decision trees that
help in selecting the cheapest key exchange method for the \textbf{low}, \textbf{normal}, \textbf{high} and \textbf{very high}
security levels, respectively, according to the security requirements. Each on the decision trees answers the $4$ questions
mentioned above. The key exchange methods are presented in order of the cheapest to the most expensive one. If two exchange methods
belong to one of the cost groups presented above, they are are presented as such in the figures too. The cost differences between
the ciphersuites within the same cost group are very small and can be ignored. If the choice is to optimize for the client/server,
ciphersuites are ordered to minimize client/server costs. If the choice is choice is to optimize for both, the
ciphersuite are ordered to minimize the total costs, \textit{i.e.} the sum of the costs for the client and the server.

As an example of how to use the decision trees in order to select the cheapest key exchange method, let us consider the scenario
where the desired security level is \textbf{normal}, asymmetric authentication is required, \gls{pfs} is not and we would like to
minimize the cost for the constrained client. Since the chosen security level is normal, \ref{fig:dt-normal-sl} will be used.
We begin at the \textit{Optimize For} node and go left, to follow the \textit{client} path, since that's the peer that we
want to optimize for. Since asymmetric authentication is required, from the \textit{Asymm Auth?} node we follow the \textit{yes}
path. This takes us to the \textit{PFS?} node, where we go right to follow the \textit{no} path, since \gls{pfs} is not required.
We finally arrive at a terminal node which lists the suitable key exchange methods, starting with the cheapest one.
In our case, the least costly key exchange method is either \textit{RSA} or \textit{RSA-PSK}. Both of them belong to the same
cost group for having very similar costs, thus both are presented in the same numeric position. The second least costly option
is \textit{ECDH-RSA}, and the most costly one is \textit{ECDH-ECDSA}. Table \ref{table:client-hs-cost-all-sls} can be consulted for
precise Handshake costs. After making a decision on which key exchange method(s) is(are) acceptable, either one of ciphersuites that
use them can be chosen.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/dt_low_sl.png}
  \centering \caption{\label{fig:dt-low-sl} \textbf{low} security level decision tree for the cheapest key exchange}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/dt_normal_sl.png}
  \centering \caption{\label{fig:dt-normal-sl} \textbf{normal} security level decision tree for the cheapest key exchange}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/dt_high_sl.png}
  \centering \caption{\label{fig:dt-high-sl} \textbf{high} security level decision tree for the cheapest key exchange}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/dt_veryhigh_sl.png}
  \centering \caption{\label{fig:dt-veryhigh-sl} \textbf{very high} security level decision tree for the cheapest key exchange}
\end{figure}

In section \ref{sec:auth-cost-in-tls} we analyzed the cost of authentication in \gls{tls} and in section \ref{sec:pfs-cost-in-tls}
the cost of \gls{pfs} in \gls{tls}. Tables \ref{table:tls-auth-cost-client}, \ref{table:pfs-cost-server},
\ref{table:pfs-cost-client} and \ref{table:pfs-cost-server} show the authentication and \gls{pfs} costs for the client and the server,
respectively. However, in order to compute the cost of the Handshake for a given key exchange method and security level, it
is not enough to sum the corresponding values from the authentication and \gls{pfs} cost tables. The overhead of establishing the \gls{tls} connection and
the parsing/record layer costs. As discussed previously, we can consider the cost of the \textit{PSK} handshake as the \gls{tls} overhead.
The parsing and the record layer costs are additional costs that the
peers spend in parsing and reading/writing certain messages not included in the \gls{tls} overhead cost.
Here, reading/writing does not refer to reading/writing to the network, but rather to the record layer. Namely, it is the cost of creating/verifying
the message \gls{mac}. We will refer to those costs as \textit{Additional Costs}.

The majority of the \textit{Additional Costs} come from the \textit{Certificate} message.
This message is omitted entirely in the \textit{PSK} key exchange. In ciphersuites that use asymmetric authentication,
the client has to read the  \textit{Certificate} message from the record layer, parse the \textit{der} encoded certificate into internal fields and
check the validity of its fields, such as the not valid before/after dates. The server has to write the \textit{Certificate} message to the
record layer.

Thus, we can use the following formula to compute the cost of the \gls{tls} Handshake cost for a key exchange method and
security level: $Handshake Cost = TLS Overhead + Auth Cost + PFS Cost + Additional Costs$. The \textit{TLS Overhead} is the cost of the
\textit{PSK} key exchange and can be obtained from table \ref{table:client-hs-cost-all-sls} for the client
and from table \ref{table:server-hs-cost-all-sls} for the server. \textit{Auth Cost} is the cost of authentication and can be obtained
from \ref{table:tls-auth-cost-client} for the client and from table \ref{table:tls-auth-cost-server} for the server. \textit{PFS} cost
is the cost of \gls{pfs} and can be obtained from table \ref{table:pfs-cost-client} for the client and from table \ref{table:pfs-cost-server}
for the server. Part of \textit{Additional Costs} can be obtained from table \ref{table:cert-parse-cost}, which presents the most relevant
costs when parsing the \textit{Certificate} message.

The certificate are either signed with
\gls{rsa} or \gls{ecdsa}. In \textit{mbedTLS 2.7.0} there are $31$ ciphersuites that use \gls{rsa}-signed certificates and $17$ ciphersuites
that use \gls{ecdsa}-signed certificates. Table \ref{table:cert-parse-cost} contains the cost of parsing the certificate for each algorithm
and security level. This costs do not include checking the certificate's signature, but rather reading the certificate from the record layer,
parsing the \textit{der}-encoded certificate into internal fields, checking the validity of each field and creating a hash of the fields.
The presented values an average of $31$ executions for \gls{rsa} and $17$ for \gls{ecdsa}, each one with a
different ciphersuite. The numbers in parenthesis are standard deviation. An analysis of the table shows that the cost is very similar across all
algorithms and security levels.

\begin{table}[]
\begin{tabular}{|l|l|l|l|l|}
\hline
               & \textbf{low}   & \textbf{normal} & \textbf{high} & \textbf{very high} \\ \hline
\textbf{RSA}   & 511728 (45373) & 544227 (47594)  & 607542 (51576) & 735237 (59853)      \\ \hline
\textbf{ECDSA} & 548841 (45064) & 662348 (45175) & 666866 (45923)  & 704135 (48247)        \\ \hline
\end{tabular}
\centering \caption{ \label{table:cert-parse-cost} Additional costs of parsing the certificate}

\end{table}

As an example, we will compute the client's Handshake cost for the \textbf{high} security level with \textit{ECHDE-RSA}
key exchange, from the \gls{tls} security service costs that we presented in sections \ref{sec:auth-cost-in-tls} and \ref{sec:pfs-cost-in-tls}
First, we will need to get the \textit{TLSOverhead} value. We can obtain in from the entry located at the
\textit{ECDHE-RSA} row and \textit{high} column in table \ref{table:client-hs-cost-all-sls}: $1355005$. \textit{AuthCost} can be obtained
from the \textit{ECDHE-RSA} row and \textit{high} column in table \ref{table:tls-auth-cost-client}: $4413164$. Similarly \textit{PFSCost}
can be obtained from table \ref{table:pfs-cost-client}, where the \textit{ECDHE-RSA} row and \textit{high} column intersect: $90231688$.
For the additional certificate parsing costs, we will consult table \ref{table:cert-parse-cost}. Since the certificate is an \gls{rsa} signed one,
we will use the value from \textit{RSA} row and \textit{high} column: $607542$. All that's left now is insert those values in the formula:
$Handshake Cost = TLS Overhead + Auth Cost + PFS Cost + Additional Costs = 1355005 + 4413164 + 90231688 + 607542 = 96607399$.

This value was obtained by decomposing the \gls{tls} Handshake into the security services and adding up their costs. As we can see,
the cost computed using the formula is very close to the actual Handshake cost when evaluated as a whole,
which can be found in in table \ref{table:client-hs-cost-all-sls} (\textit{ECDHE-RSA} row and \textit{high} column): $96730901$.
The difference of $123502$ ($96730901-96607399$) CPU cycles comes from other additional costs, such as reading and writing slightly larger
messages, namely the \textit{ServerKeyExchange} and the \textit{ClientKeyExchange}.

\subsection{Confidentiality and Integrity Cost Analysis} \label{sec:confid-costs}

Having analyzed the cost of authentication and \gls{pfs}, we will now briefly analyze the cost of the confidentiality and integrity services.
In \gls{tls}, it does not make sense to analyze both of the services separately, since they're offered as a whole as a part of the ciphersuite.
For this reason, we will analyze them together.

In \textit{mbedTLS 2.7.0} implements $13$ non-null unique encryption algorithms and $4$ unique hash functions. There are $6$ \textit{AES} 
algorithms, $4$ \textit{CAMELLIA} algorithms,
$1$ \textit{DES} algorithm, $1$ \textit{3DES} algorithm and $1$ \textit{RC4} algorithm. The $4$ available hash functions are \textit{SHA-1}, 
\textit{SHA-256}, \textit{SHA-384} and \textit{MD5}.
For non-\gls{aead} ciphers, the combination of a symmetric encryption algorithm and a hash function is used to provide the security services of confidentiality and 
integrity. For \gls{aead} ciphers the symmetric encryption algorithm provides both, confidentiality and integrity, so there is no need
to use an additional hash function.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/sym_algs_cc.png}
  \centering \caption{\label{fig:symm-encr-all} Confidentiality and integrity cost with different algorithms}
\end{figure}

Figure \ref{fig:symm-encr-all} shows the cost of encryption and \gls{mac} creation using each one of the $26$ symmetric encryption 
algorithm/hash function pairs available in \textit{mbedTLS 2.7.0}. As expected, their cost grows linearly with the amount of encrypted bytes.
An analysis of the graph shows that \textit{3DES} with \textit{SHA} is the most costly combination of an encryption algorithm with a \gls{mac} function, 
while \gls{aead} encryption algorithms 
(\textit{AES} with \textit{GCM} and \textit{CCM} modes) are the least costly block cipher algorithms. 
\textit{CAMELLIA} algorithms are more costly than their \textit{AES} counterparts.  The cost of integrity without encryption can be seen by looking at the null
encryption ciphersuites: \textit{NULL-MD5}, \textit{NULL-SHA}, \textit{NULL-SHA256} and \textit{NULL-SHA384}.
For non-\gls{aead} algorithms combined with a hash function, the majority of the cost is spent in data encryption.

In Section \ref{sec:tls-hs-cost} we analyzed the cost of the handshake. However, it only makes sense to heavily optimize handshake
if the amount of transmitted data is small. This is, in fact, true for many \gls{iot} devices. But what exactly is a \textit{small} amount of data?

In order to answer those questions we profiled the costs of encrypting data with the \textit{AES-128-GCM} (\textbf{low} and 
\textbf{normal} security levels) and \textit{AES-256-GCM} (\textbf{high} and \textbf{very high} security levels). 
We selected those algorithms because they were among the cheapest ones to provide the required security level and are preferred by
browsers, such as \textit{Google Chrome 67}. The cost of encryption and decryption for those algorithms are similar\cite{ertaul2016performance}.
For each
one of the algorithms, we encrypted data sizes from starting from $1$ byte up to $16250000$ bytes (approximately $15.5$ mega bytes),
with $100$ byte increments in each run. Thus, a total of $162500$ runs was made with each algorithm. It is expected for encryption costs to
grow linearly with the amount of encrypted data, thus we applied linear regression to the collected metrics in order in order to
obtain a formula that approximates the cost of encryption for any amount of data. Our analysis yielded the following formulas for the
cost of encryption with \textit{AES-128-GCM} and \textit{AES-256-GCM}, respectively: $NumCC=104*NumBytes+22680$ and $NumCC=105*NumBytes+22740$ ($R=1$ for both).
$NumCC$ is the number of CPU Cycles and $NumBytes$ is the number of bytes encrypted. As we cam see. the cost of \textit{AES-256-GCM} is slightly
larger than of \textit{AES-128-GCM}.

The derived formulas can be used to answer the question of when the costs spent on data encryption equate the costs
spent on performing the handshake. For example, let's compute this number for the client, when it performs an
\textit{ECDHE-ECDSA} handshake at the \textit{normal} security level. First, we obtain the number of CPU cycles
used to perform the handshake from table \ref{table:client-hs-cost-all-sls}: $168954007$. After that we simply
replace $NumCC$ with that value in the formula and solve for $NumBytes$: $168954007=104*NumBytes+22680 \Leftrightarrow NumBytes \approx 1624340$.
Thus, the client needs to send $1624340$ bytes ($\approx 1.5$ mega bytes) for the encryption costs to equate the \textit{ECDHE-ECDSA} handshake cots.

Figures \ref{fig:cli-conf-hs-low}, \ref{fig:cli-conf-hs-normal} and \ref{fig:cli-conf-hs-high} help to visualize when
when the encryption/decryption costs equate the handshake costs for the \textbf{low}, \textbf{normal} and \textbf{high}
security levels, respectively. Figures \ref{fig:srv-conf-hs-low}, \ref{fig:srv-conf-hs-normal} and \ref{fig:srv-conf-hs-high}
show the same information for the server. We did not present the graphs for the \textit{very high} security level,
because the overwhelming cost of some key exchange methods made the visual analysis of the graph hard (due to scale).

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/cli_conf_hs_low.png}
  \centering \caption{\label{fig:cli-conf-hs-low} Client handshake vs confidentiality cost for the \textbf{low} security level}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/cli_conf_hs_normal.png}
  \centering \caption{\label{fig:cli-conf-hs-normal} Client handshake vs confidentiality cost for the \textbf{normal} security level}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/cli_conf_hs_high.png}
  \centering \caption{\label{fig:cli-conf-hs-high} Client handshake vs confidentiality cost for the \textbf{high} security level}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/srv_conf_hs_low.png}
  \centering \caption{\label{fig:srv-conf-hs-low} Server handshake vs confidentiality cost for the \textbf{low} security level}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/srv_conf_hs_normal.png}
  \centering \caption{\label{fig:srv-conf-hs-normal} Server handshake vs confidentiality cost for the \textbf{normal} security level}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{img/srv_conf_hs_high.png}
  \centering \caption{\label{fig:srv-conf-hs-high} Server handshake vs confidentiality cost for the \textbf{high} security level}
\end{figure}


\subsection{Conclusions} \label{sec:ss-cost-conclusions}

In this section evaluated the cost of security services of authentication, \gls{pfs}, confidentiality and integrity
in \gls{tls}. To do this, we defined $4$ security levels and analyzed the costs for each one. The majority of
analysis was concentrated around the handshake and the security services that it offers.

In \gls{tls} there are two ways of doing authentication: \gls{psk} or asymmetric cryptography. We showed that the
cost of \gls{psk} authentication is essentially $0$ and we can consider the cost of performing the 
handshake with a \textit{PSK} ciphersuite can be considered as the \gls{tls} overhead.

In \gls{tls}, authentication with asymmetric cryptography can be done in two ways: either by using \gls{rsa}
of \gls{ecdsa}. We began by analyzing the costs of those two algorithms. We concluded that \gls{rsa} was
faster at public key operations (\textit{i.e.} signature verification) and \gls{ecdsa} was faster at private key
operations (\textit{i.e.} signature creation). An analyzes of the algorithm's costs showed that as the security level
increases, while \gls{rsa}'s cost increase exponentially, \gls{ecdsa}'s increase logarithmically. This is a result of the
\gls{ecc} properties of the algorithm.

After evaluating the costs individual algorithms that can be used to provide asymmetric authentication in \gls{tls}, we
used those results to compute the authentication cost in \gls{tls}, for each one of its key exchange methods.

After analyzing the cost of authentication, we turned our attention to \gls{pfs}. In \gls{tls} there are two ways
of achieving \gls{pfs}: either by using \gls{ecdh} or \gls{dh}. We decomposed each algorithm into individual steps
and analyzed their cost. As the security level increases, the cost of \gls{dh} grows exponentially, while the cost
of \gls{ecdh} logarithmically. In that sense, \gls{dh} is similar to \gls{rsa} and \gls{ecdh} to \gls{ecdsa}.
This similarity is a consequence of the fact, the underlying mathematical operation is the same for \gls{dh} and
\gls{rsa} (modular exponentiation), and for \gls{ecdh} and \gls{ecdsa} (multiplication of a scalar by a point on 
the elliptic curve).

After evaluating the costs of the algorithms that can be used to provide \gls{pfs} in \gls{tls}, we used those results
to arrive that \gls{pfs} cost for each on of the key exchange methods.

Having computed the costs of authentication and \gls{pfs} we were now ready to compute the cost of the \gls{tls} handshake
as a whole. We presented a formula that decomposed the handshake costs its individual parts: $Handshake Cost = TLS Overhead + Auth Cost + PFS Cost + Additional Costs$. 
We compared the costs
obtained from the formula to the actual handshake cost values that we acquired by profiling various client-server
executions and shown that both are similar.

Finally, we analyzed the costs of confidentiality and integrity. First, we compared the costs of all of the
symmetric algorithm/hash function combinations available in \textit{mbedTLS 2.7.0}. As expected,
\gls{aead} algorithms preformed the best among the block ciphers. After that we chose two \gls{aead} ciphers and
analyzed how much data it would be necessary to encrypt with them to equate the handshake costs.

\section{Conclusion}

The lack of security in \gls{iot} is a serious issue that can lead to a high monetary costs,
when botnets infect the devices. Recent
attacks clearly show that serious damage can be caused \cite{sec17ant94:online}. An old saying attributed to the
\gls{nsa} states that "Attacks always get better; they never get worse".
Combined with the fact that the number of \gls{iot} devices is growing at a high
pace, without any major improvements to their security, makes it clear
that it is fundamental for this issue to be addressed.

\gls{tls} is one of the most communication security protocols in the world. It offers the
security services of authentication, confidentiality, privacy, integrity, replay
protection and perfect forward secrecy. It is not a requirement to use all of
those services for every TLS connection. The protocol is similar to
a framework, in the sense that you can enable some of the security
services on a per-connection basis.

While \gls{tls} does have many configurations, not all of them can be used with the \gls{iot},
due to the constrained nature of the devices. In many cases it is necessary to make security/cost
trade-offs. In order to be able to make them, it is important to know the costs of each security
service. Current work offers no such information. Thus, a software developer wishing to use \gls{tls}
for connection security in a constrained environment does not have a reference to go to.

In our work, we decomposed \gls{tls} into individual parts and evaluated the cost of each security service.
We have evaluated the cost of every \gls{tls} configuration available in \textit{mbedTLS 2.7.0} and the underlying
algorithms. The herein presented results can be used to make informed decisions about the security/cost trade-offs,
specific to the environment.

The results presented here were obtained on a powerful, modern-day computer. Despite that, they are still
relevant when considering the costs on constrained \gls{iot} devices. While on a different device, the absolute cost 
numbers will be different, they would still maintain a similar proportion one to another and follow a similar trend.
Moreover, the developed tooling can be used to obtain profiling results on any machine, thus giving device-specific 
cost information. The formula used to obtain the CPU cycle count estimate can also be changed to one's needs.

\subsubsection{Future Work}

While the use of \textit{callgrind} helped to obtain and analyze large a amount of different results, there are other
cost metrics that would be interesting to analyze. First, it is important to remember than an estimate of the number
of CPU cycles was used. It would be of interest to obtain the actual count of CPU cycles, by querying the
processor's counters directly. Tools such as PAPI\cite{dongarra2001using} can be used for this purpose.

Many \gls{iot} devices have very limited power (\textit{e.g.} working of a battery). Thus, it would be interesting
analyze the cost of \gls{tls} in terms of power usage. This would also allow to reach interesting conclusions, such as:
\textit{Using the TLS configuration X would reduce the device's battery life by Y days}.

Time is another interesting metric to consider. While an \gls{iot} device might be connected to a power source and
only make occasional connections, such a motion sensor, it would be of little use if it takes it a very long time
to establish connection. This would allow to associate time values to each part of \gls{tls}.
Finally, all of the mentioned metrics should be obtained on \gls{iot} hardware.

% ---- Bibliography ----
%
\nocite{*}
\bibliographystyle{unsrt}
\bibliography{tls_for_iot,papers}
%
\printglossary[style=long]
%
\end{document}
