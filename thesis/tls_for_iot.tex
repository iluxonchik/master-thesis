% This is the file where my Master Thesis will be written. It uses the adapted
% LNCS Template.
%
% I'll be using a few codes in the comments, which can be easily looked up:
% * NOTE: theseis-text related comments
% * TODO: thesis-related TODO's
% * WARN: latex/formatting-related warningss
%
% WARN: for running head, subsititute the line below by:
% \documentclass[runningheads,a4paper]{llncs}
\documentclass{llncs}
%
%%% WARN: custom extension
\usepackage{xcolor}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}

%%% GLOSSARIES
\usepackage{glossaries}

%%% inline code
\usepackage{xparse}
\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

%%% figures
\usepackage{graphicx}
\usepackage{wrapfig}


\makeglossaries

\newacronym{tls}{TLS}{Transport Layer Security}%
\newacronym{ssl}{SSL}{Secure Sockets Layer}%
\newacronym{ietf}{IETF}{Internet Engineering Task Force}%
\newacronym{mac}{MAC}{Message Authentication Code}%
\newacronym{psk}{PSK}{Pre-Shared Key}%
\newacronym{aead}{AEAD}{Authenticated Encryption With Associated Data}%
\newacronym{pkc}{PKC}{Public Key Cryptography}%
\newacronym{hkdf}{HKDF}{HMAC-based Extract-and-Expand Key Derivation Function}%
\newacronym{html}{HTML}{Hypertext Markup Language}%
\newacronym{https}{HTTPS}{Hypertext Transfer Protocol Secure}%
\newacronym{ecc}{ECC}{Elliptic Curve Cryptography}%
\newacronym{iv}{IV}{Initialization Vector}%
\newacronym{ecdh}{ECDH}{Elliptic Curve Diffie-Hellman}%
\newacronym{ecdhe}{ECDHE}{Elliptic Curve Diffie-Hellman Ephemeral}%
\newacronym{ecdsa}{ECDSA}{Elliptic Curve Digital Signature Algorithm}%
\newacronym{rfc}{RFC}{Request For Comment}%
\newacronym{prf}{PRF}{Pseudo-Random Function}%
\newacronym{rsa}{RSA}{Rivest-Shamir-Adleman}%
\newacronym{dh}{DH}{Diffie-Hellman}%
\newacronym{pms}{PMS}{premaster secret}%
\newacronym{pubk}{PubK}{Public Key}%
\newacronym{privk}{PrivK}{Private Key}%
\newacronym{dsa}{DSA}{Private Key}%
\newacronym{pfs}{PFS}{Perfect Forward Secrecy}%
\newacronym{mitm}{MITM}{Man In The Middle}%



%%% WARN: added as specified here:
% https://tex.stackexchange.com/questions/272200/table-of-contents-showing-the-title-as-only-entry-latex
\setcounter{tocdepth}{2}
\makeatletter
\renewcommand*\l@author[2]{} % removes author name from TOC
\renewcommand*\l@title[2]{} % removes title name from TOC
\makeatletter
%%%
%
\usepackage{makeidx}  % allows for indexgeneration
%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%
\addtocmark{TLS For IoT} % additional mark in the TOC

\tableofcontents
\newpage

\mainmatter              % start of the contributions
%
\title{Transport Layer Security Protocol For Internet Of Things}
%
\titlerunning{TLS For IoT}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{{Illya Gerasymchuk} \\
\email{illya.gerasymchuk@tecnico.uliboa.pt},\\ WWW home page:
\texttt{https://iluxonchik.github.io/}}
%
\authorrunning{Illya Gerasymchuk} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Illya Gerasymchuk}
%
\institute{Instituto Superior Técnico}
% WARN: supper hacked-in
\supervisors{Ricardo Chaves, Aleksandar Ilic}
\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the paper
using at least 70 and at most 150 words. It will be set in 9-point
font size and be inset 1.0 cm from the right and left margins.
There will be two blank lines before and after the Abstract. \dots
\keywords{TLS, IoT, cryptography, protocol, lightweight cryptography}
\end{abstract}
%
\section{Intoduction}
%
\todo{Intruduce the topic: explain what is IoT; what is TLS; what are the issues with
using RAW TLS with IoT(power, computation, limited resources).}
%
\subsection{Goals}
%
\section{Related Work}
%
\todo{Tell that first I describe the parts of TLS that are common to both and then
specialize for TLS 1.2 and TLS 1.3}
%
\section{The TLS Protocol}
TLS stands for Transport Layer Security, it's a \textbf{client-server} protocol
that runs on top a \textbf{connection-oriented and reliable transport protocol},
such as \textbf{TCP}. Its main goal is to provide \textbf{privacy} and \textbf{integrity}
between the two communicating peers. Privacy implies that a third party will not
be able to read the data, while integrity means that a third party will not be
able to alter the data.

In the TCP/IP Protocol Stack, \gls{tls} is placed between the \textbf{Transport}
and \textbf{Application} layers. It's designed to make the application developer's
life easier: all the developer has to do is create a "secure" connection, instead
of a "normal" one.

\todo{Re-write what's below. It's good to include something like this,
but I need to work on the wording.}
From the top-level view, in a typical connection, there are three basic steps
that \gls{tls} is responsible for:
\begin{enumerate}
  \item \textbf{Negotiate security parameters} - the communicating peers agree on
  a set of security parameters to be used in a \gls{tls} connection, such as the
  algorithm used for bulk data encrytion, as well as the secret keys.
  \item \textbf{Authenticate one to another} - usually only the server authenticates
  to the client.
  \item \textbf{Communicate securely} - use the negotiated security parameters
  to encrypt and authenticate the data, communicating securely one with another.
\end{enumerate}


%%% NOTE: place this in intro? Is this even needed?
%%% NOTE: review, rephrase
%%% NOTE: find better placement
\subsubsection{SSL vs TLS: What's The Difference?}
You will find the names \gls{ssl} and \gls{tls} used interchangeably in the literature,
so I think it's important to distinguish both. \gls{tls} is an evolution of the \gls{ssl} protocol. The protocol changed
its name from \gls{ssl} to \gls{tls} when it was
standardized by the \gls{ietf}.\gls{ssl}
was a proprietary protocol owned by Netscape Communications, and The \gls{ietf}
decided that it was a good idea to standarize it, which resulted in \codeword{RFC 2246} \cite{RFC2246},
specifying \gls{tls} 1.0, which was nothing more than a new version \gls{ssl} 3.0,
very few changes were made.
%
% TODO: add some data supporting the TLS 1.2 usage claim
In this document, I'll be concentrating on \gls{tls} 1.2 and \gls{tls} 1.3 protocols.
The first one is the most recently standardized version of \gls{tls} and the latter
is currently and in-draft version with many improvements and optimizations relevant
for the topic of this dissertation. Despite the protocol name not suggesting it \gls{tls} 1.3 is
very different from \gls{tls} 1.2, in fact, it should've probably been called
\gls{tls} 2.0 instead. For this reason, I will first describe what is common to
both protocols and then go into the relevant details about each one.
%

\todo{Explain what RFCs are?}
%
\subsection{Security Services}
%
\gls{tls} provides the following 3 security services:
\begin{itemize}
\item \textbf{authentication} - both, \textbf{peer entity} and \textbf{data origin} (or \textbf{integrity})
authentication.
\subitem \textbf{peer entity authentication} - we can be sure that we’re talking to certain entity, for example, \codeword{www.google.com}.
This is achieved thought the use of \textbf{asymmetrical} or \gls{pkc} (for example, \codeword{RSA} and \codeword{DSA})
or \textbf{symmetric key cryptography}, using a \gls{psk}.
\item \textbf{confidentiality} - the data transmitted between the communicating
entities (the client and the server) is encrypted. Symmetric cryptography is
used of data encryption (for exmaple, \codeword{AES}).
\item \textbf{integrity} (also called \textbf{data origin authentication}) - we can be sure that the data was not modified or forged,
\textit{i.e.}, be sure that the data that we’re receiving is coming from the expected entity (for example, we can be sure
that the \codeword{index.html} file sent to us when we connected to \codeword{www.google.com} in fact
came from \codeword{www.google.com} and that it was not modified (i.e tampered with) en
route by an attacker (\textbf{data integrity}). This is achieved through the use
of a keyed \gls{mac} or an \gls{aead} cipher.
\end{itemize}

Despite using \gls{pkc}, \gls{tls} does \textbf{not} provide \textbf{non-repudiation services}:
neither \textbf{non-repudiation with proof of origin}, which addresses the user denying
having sent a message, not \textbf{non-repudiation with proof of delivery}, which
addresses the user denying the receipt of a message. This is due to the fact, that
instead of using \textbf{digital signatures}, either a keyed \gls{mac} or an \gls{aead}
cipher is used, both of which require a \textbf{shared secret} to be used.

You are not required to use all of the 3 security services in every situation.
You can think of \gls{tls} as a framework that allows you to select which security
services you want to use for a communication session. As an example, you might
ignore certificate validation, which means you're ignoring the \textbf{authentication}
guarantee. There are some differences regarding this claim between \gls{tls} 1.2
and \gls{tls} 1.3, for example, while in the first you have a \codeword{null}
cipher (no authentication, no confidentiality, no integrity), in the latter
this is not true, since it deprecated all non-\gls{aead} ciphers in favor of
\gls{aead} ones.

\subsubsection{Cipher Spec vs Cipher Suite}

The meaning of these terms differs in \gls{tls} 1.2 and \gls{tls} 1.3. For \gls{tls} 1.2,
\textbf{cipher spec} is the message encryption algorithm and the message
authentication algorithm, while the \textbf{cipher suite} is the \textbf{cipher spec},
as well as the  \textbf{key exchange} algorithm. In \gls{tls} 1.3, the
 \textbf{cipher spec} has been removed altogether, since the  \textbf{ChangeCipherSpec}
 protocol has been removed. The concept of \textbf{cipher suite} has been updated
 to define the pair of \gls{aead} algorithm and hash function to be used with
 \gls{hkdf}: in \gls{tls} 1.3 the  \textbf{key exchange} algorithm is negotiated via
 extensions. You'll find more details on this below.

\subsection{TLS (Sub)Protocols}

In reality \gls{tls} is composed of several protocols, a brief description of each
one of which follows:
\begin{itemize}
  \item \textbf{\gls{tls} Record Protocol} - the lowest layer in \gls{tls}. It's
  the layer that runs directly on top of \textbf{TCP/IP} and it serves as an
   \textbf{encapsulation for the remaining sub-protocols} (\codeword{4} in case of \gls{tls} 1.2
   and \codeword{3} in case of \gls{tls} 1.3). To the  \textbf{Record Protocol},
   the remaining sub-protocols are what \codeword{TCP/IP} is to \codeword{HTTP}.
  \item \textbf{\gls{tls} Handshake Protocol} - the core protocol of \gls{tls}.
  Allows the communicating peers to \textbf{authenticate} one to another and negotiate
  a \textbf{cipher suite} (\textbf{cipher suite} and key exchange algorithm in case of \gls{tls} 1.3) which will be used to provide the security services. For \gls{tls} 1.2,
  \textbf{compression} method is also negotiated here.
  \item \textbf{\gls{tls} Alert Protocol} - allows the communicating peers to
  signal potential problems.
  \item \textbf{\gls{tls} Application Data Protocol} - used to transmit data securely.
  \item \textbf{\gls{tls} Change Cipher Spec Protocol} (removed in \gls{tls} 1.3) -
  used to activate the initial \textbf{cipher spec} or change it during the connection.
\end{itemize}

\begin{wrapfigure}{R}{0.3\textwidth}
\centering
\includegraphics[width=0.25\textwidth]{img/tls-sub-protocols.png}
\caption{\label{fig:tls-subprotocols} TLS (Sub)protocols and Layers}
\end{wrapfigure}

Figure \ref{fig:tls-subprotocols} shows the subprotocols composing tls.

\paragraph{TLS Connections and Sessions}

\todo{define what it means to be cryptographically protected?}

It's important to distinguish between a \textbf{TLS session} and a \textbf{TLS connection}.
\begin{itemize}
  \item \textbf{TLS sesion} - assosciation between two communicationg peers that's
  created by the \textbf{TLS Handshake Protocol}, wich defines a set of negotiated paramters
  (cyrptographic and others, depending on the \gls{tls} version, such as
  the compression algorithm) that are used by the \textbf{TLS connections associated
  with that session}. A single \textbf{TLS session} can be shared among multiple
  \textbf{TLS connections} and its main purpuse is to avoid the expensive negotiation
  of new parameters for each \textbf{TLS connection}. For example, let's say
  you download an \gls{html} page over \gls{https} and that page referrences
  some images from that same server, also using \gls{https}, instead of your
  web browser negotiating a new \gls{tls} session again, it can re-use the the
  one you established to download the \gls{html} page in the first place,
  saving time and computational resources. Session resumption can be done using various
  approaches, such as \textbf{session identifiers}, described throughout \codeword{Section 7.4}
  of \codeword{RFC 5246} \cite{RFC5246}, \textbf{session tickets}, defined in
  \codeword{RFC 5077} \cite{RFC5077}. \todo{Re-write example better.}
  \item \textbf{TLS connection} - used to actually transmit the cryptographically
  protected data. For the data to be cryptographically protected, some parameters,
  such as the \codeword{secret keys} used to encrypt and authenticate the transmitted
  data need to be established; this is done when a \textbf{TLS session} is created,
  during the \textbf{TLS Handshake Protocol}.
\end{itemize}

\subsubsection{\gls{tls} Record Processing}
A \gls{tls} record must go through some processing before it can tbe sent over the netwrok.
This processing involves the following steps (\codeword{4} for \gls{tls} 1.2 and \codeword{3} for \gls{tls} 1.3):

\begin{enumerate}
  \item \textbf{Fragmentation} - the \gls{tls} \codeword{Record Layer} takes arbitrary-length data and \textbf{fragments}
  it into manageable pieces: each one of the resulting fragments is called a \codeword{TLS Plaintext}.
  \item  \textbf{Compression} (removed in \gls{tls} 1.3) - the \codeword{TLS Record Layer} compresses the
  \codeword{TLSPlaintext} structure according to the negotiated compression method,
  outputting \codeword{TLSCompressed}. Compression is optional. If the negotiated compression
  method is \codeword{null}, \codeword{TLSCompressed} is the same as \codeword{TLSPlaintext}.
  \item \textbf{Cryptographic Protection} - in case of \gls{tls} 1.2, either an
  \gls{aead} cipher or a separate encryption and \gls{mac} functions transform a
  \codeword{TLSCompressed} fragment into a \codeword{TLSCipherText} fragment. In case
  of \gls{tls} 1.3, the \codeword{TLSPlaintext} fragment is transformed into a \codeword{TLSCipherText}
  by applying an \gls{aead} cipher.
  \item Append the \textbf{TLS Record Header} - encapsulate \codeword{TLSCipherText}
  in a \codeword{TLS Record}.
\end{enumerate}

\begin{wrapfigure}{r}{0.4\textwidth}
\centering
\includegraphics[width=0.7\textwidth]{img/tls-record-processing.jpg}
\caption{\label{fig:tls-record-processing}TLS Record Processing}
\end{wrapfigure}

The process described above, as well as the structure names are depicted in figure \ref{fig:tls-record-processing}.
Step \codeword{2} is not present in \gls{tls} 1.3. The structure names are exactly as the appear in the \gls{tls} specifications.

\subsection{TLS Keying Material}
Secret keys are at the base of most cryptographic operations.
In order for both communicating peers to be able to encrypt and decrypt data
using symmetric cyrpto aglorithms, they need to \textbf{share} the same key
somehow. In \gls{tls}, both, the client and a server derive the \textbf{same set of keys}
independetely, through the exchanged messages in the \gls{tls} Handshake Protocol.

When communicating with one anohter, the client uses one key to
encrypt the data to be sent to the server and another different key to decrypt the data
that it receives from the server. This means that in order to deal with data
encryption and decryption, both of the communicating entities have two keys:
one to encrypt the outgoing data and one to decrypt the incoming data. Those keys
have different names in \gls{tls} 1.2 and \gls{tls} 1.3, but they serve the same
basic purpose. In this general description, I'll refer to them as \codeword{client_write key}
(used by the client to encrypt the data to be sent), \codeword{client_read_key}(used by the client to
decrypt the incoming data from the server), \codeword{server_write_key}(used by the server to encrypt
the data to be sent) and \codeword{server_read_key}(used by the server to decrypt the incoming
data from the client). Note, that the following relationships must hold:
\codeword{client_write_key == server_write_key} and \codeword{client_read_key == server_write_key}.

Besides the secret keys mentioned previously, in \gls{tls} 1.2 you might also have other ones,
depending on the cipher suite in use. \todo{Describe this in a little more detail,
giving examples, when describing TLS 1.2 Key Managment}.

\gls{tls} 1.3's keying material generation is a little more complex, since different
keys are used to encrypt data throughout the Handshake Protocol, as well a new key
is generated for the Application Data protocol. This can be explained by the fact
that while in \gls{tls} 1.2 the data only begins to be encrypted after the handshake
is complete, in the Application Data protocol, the encryption begins earlier,
\gls{tls} 1.3, with some of the Hanshake messages encrypted, as well as features
such as \textbf{early client/server data} and \textbf{0-RTT Data}.

With this the common description of the \gls{tls} of protocols ends and we'll jump
into the specifics of the two verions. I'll be mostly concentrating on the
 \textbf{Handshake Protocol}, since this is where my work will be concentrated and
 it's the main part, where the most interesting and important things happen.

\subsection{TLS 1.2}
The latest standardized version of \gls{tls} is 1.2 and it's defined in \codeword{RFC 5246} \cite{RFC5246}.
\todo{DESCRIBE TLS 1.2 in genreal, put images of handshakes here, later refer to them
in the specific parts, just like the tls RFCs do}.

\section{TLS 1.2 Keying Material Generation}
The generation of secret keys, used for various cryptographic operations involves the
following steps (in order):

\begin{itemize}
  \item Generate the \textbf{premaster secret}
  \item From the \textbf{premaster secret} generate the \textbf{master secret}
  \item From the \textbf{master secret} generate the various secret keys, which
  will be used in the cryptographic operations.
\end{itemize}

\todo{talk about all of the keys present in TLS 1.2 HERE}

\section{TLS 1.2 Key Exchange Methods}
The way the \textbf{permaster secret} is generated depends on the key exchange
method used. In fact, this is the only phase of the keying material generation
phase that is variable for a fixed cipher suite (because a cipher suite defines
the \gls{prf} function to be used), the rest remains exactly the same. The derivation
of the \textbf{master secret} from the \textbf{premaster secret}, as well as the
derivation of the bulk encryption keys, \gls{mac} keys and \gls{iv}s from the \textbf{master secret}
that follows \textbf{is not impacted by the key exchange method} in use.

You have quite a few choices when it comes to key exchange methods. Some of them
are defined in the base spec (\codeword{RFC5246} \cite{RFC5246}), while others
in separate \codeword{RFCs} (such as the \gls{ecc} based key exchange, specified
in \codeword{RFC4492} \cite{RFC4492}).

The base spec specifies 4 key exchange methods, one using \gls{rsa} and 3 using
\gls{dh}:

\begin{itemize}
  \item static \gls{rsa} (\codeword{RSA}) [removed in \gls{tls} 1.3] - the client generates the \gls{pms}, encrypts it with the
  server's \gls{pubk} (which it obtained from the server's \codeword{X.509}certificate),
  sending it to the server, which decrypts it using the corresponding \gls{privk}.
  This key exchange method offers authenticity, but does not offer \gls{pfs}.
  \item anonymous \gls{dh} (\codeword{DH_annon}) [removed in \gls{tls} 1.3] - a \gls{dh} key exchange is
  performed and an \textbf{ephemeral} key is generated, but the exchanged \gls{dh}
  parameters are \textbf{not authenticated}, making the resulting key exchange
  vulnerable to \gls{mitm} attacks. \gls{tls} 1.2 spec states that cipher suites
  using \codeword{DH_annon} \textbf{must not} be used, unless the application
  layer explicitly requests so. This key exchange offers \gls{pfs}, but no
  authenticity.
  \item fixed/static \gls{dh} (\codeword{DH}) [removed in \gls{tls} 1.3] - the server's/client's public \gls{dh} parameter
  is embedded in its certificate. This key exchange method offers authenticity,
  but does not offer \gls{pfs}.
  \item epehemeral \gls{dh} (\codeword{DHE}) - each run of the protocol, uses
  different pubic \gls{dh} parameters, which are generated dynamically. This results
  in a different, epehemeral key being generated every time. The public parameters
  are then digitally signed in some way, usually using the sender's private
  \gls{rsa} (\codeword(DHE_RSA)) or \gls{dsa} (\codeword{DHE_DSS}) key. This key
  exchange offers both authenticity and \gls{pfs}.
\end{itemize}

When either of the \gls{dh} variants is used, the value resulting from the exchange is used
as the \gls{pms} (without the leading \codeword{0}'s). Usually, only the server's
authenticity is desired, but client's can also be achieved if it provides the
server its certificate. Below is a table that summarizes the security properties
offered by each key exchange method.

\begin{table}[]
\centering
\caption{Key exchange methods and security properties}
\label{kemsp}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Key Exch Meth} & \multicolumn{1}{l|}{Authentication} & PFS                    \\ \hline
RSA                          & X                                   &                        \\ \hline
DH\_anon                     & \multicolumn{1}{l|}{}               & \multicolumn{1}{c|}{X} \\ \hline
DH                           & X                                   &                        \\ \hline
DHE                          & X                                   & \multicolumn{1}{c|}{X} \\ \hline
\end{tabular}
\end{table}

Note that in \gls{tls} 1.3, all of static \gls{rsa} and \gls{dh} cipher suites
have been removed: all of the \gls{pubk} exchange methods now provide \gls{pfs}.
Even though, anonymous \gls{dh} has also been removed from \gls{tls} 1.3, you can
still have unauthenticated connections by either using \textbf{raw public keys} \cite{RFC7250}
or by not verifying the certificate chain and any of it's contents.

\todo{NOTE: I did't cover specifics of how the client generates the premaster secret, etc}

The \gls{ecc}-based key exchange (\gls{ecdh} and \gls{ecdhe}) and authentication (\gls{ecdsa})
algorithms are defined in \codeword{RFC4292} \cite{RFC4292}, which is also referenced
in \codeword{RFC5246} \cite{RFC4256}. The document introduces five new
\gls{ecc}-based key exchange algorithms, all of which use \gls{ecc} to compute
the \textbf{premaster secret}, differing only in whether the negotiated
keys are epehemeral (\gls{ecdh}) or long-term (\gls{ecdhe}), as well as the mechanism (if any) used to
authenticate them. Three new \gls{ecdsa} \textbf{client authentication} mechanisms are also defined,
differing in the algorithms that the certificate must be signed with, as well
as the key exchange algorithms that they can be used with.
Those features are negotiated through the \gls{tls} Extension Mechanism.

\subsection{TLS 1.2 Handshake Protocol}

This phase is responsible for producing the the cryptographic parameters for the
session state. You can see

%
\paragraph{Notes and Comments.}
This is an example of a paragraph. Note the styling.

\subsection{TLS 1.3}
Despite the protocol name not suggesting it \gls{tls} 1.3 is
very different from \gls{tls} 1.2, in fact, it should've probably been called
\gls{tls} 2.0 instead.

\subsubsection{How Do Peers Distinguish Different TLS Versions?}

\todo{Talk about version numbers}

\subsection{TLS Extension Mechanism}

\todo{Describe the Extended ClientHello/ServerHello. Use one description for both,
 TLS 1.2 and TLS 1.3}

\subsection{The Problem With Compression In TLS}

\todo{explain why compression was removed (BEAST and CRIME attacks) and how it
can be fixed.}

\subsection{Theory}

\todo{Explain: public key crypto, certificates, AEAD ciphers}

%
% ---- Bibliography ----
%
\nocite{*}
\bibliographystyle{splncs03}
\bibliography{tls_for_iot}
%
\printglossary[style=long]
%
\end{document}
